<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="阅读阮一峰JavaScript标准参考教程的读书笔记，写下来，加深记忆。 语法对象生成对象对象就是一组“键值对”（key-value）的集合，是一种无序的符合数据集合。1234567var obj = &amp;#123;  foo: &amp;apos;Hello&amp;apos;,  bar: &amp;apos;World&amp;apos;&amp;#125;;//第一个键值对是foo: &amp;apos;Hello&amp;apos;，其中foo">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript标准参考教程笔记">
<meta property="og:url" content="http://yoursite.com/2018/01/10/JavaScript标准参考教程笔记/index.html">
<meta property="og:site_name" content="和元宝共同成长的日子">
<meta property="og:description" content="阅读阮一峰JavaScript标准参考教程的读书笔记，写下来，加深记忆。 语法对象生成对象对象就是一组“键值对”（key-value）的集合，是一种无序的符合数据集合。1234567var obj = &amp;#123;  foo: &amp;apos;Hello&amp;apos;,  bar: &amp;apos;World&amp;apos;&amp;#125;;//第一个键值对是foo: &amp;apos;Hello&amp;apos;，其中foo">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2018/01/20/5a631288266b7.png">
<meta property="og:updated_time" content="2018-03-15T05:38:45.876Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript标准参考教程笔记">
<meta name="twitter:description" content="阅读阮一峰JavaScript标准参考教程的读书笔记，写下来，加深记忆。 语法对象生成对象对象就是一组“键值对”（key-value）的集合，是一种无序的符合数据集合。1234567var obj = &amp;#123;  foo: &amp;apos;Hello&amp;apos;,  bar: &amp;apos;World&amp;apos;&amp;#125;;//第一个键值对是foo: &amp;apos;Hello&amp;apos;，其中foo">
<meta name="twitter:image" content="https://i.loli.net/2018/01/20/5a631288266b7.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/10/JavaScript标准参考教程笔记/"/>





  <title>JavaScript标准参考教程笔记 | 和元宝共同成长的日子</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">和元宝共同成长的日子</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/10/JavaScript标准参考教程笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="左冬">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和元宝共同成长的日子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript标准参考教程笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T20:33:25+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>阅读阮一峰JavaScript标准参考教程的读书笔记，写下来，加深记忆。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="生成对象"><a href="#生成对象" class="headerlink" title="生成对象"></a>生成对象</h3><p>对象就是一组“键值对”（key-value）的集合，是一种无序的符合数据集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  foo: &apos;Hello&apos;,</span><br><span class="line">  bar: &apos;World&apos;</span><br><span class="line">&#125;;</span><br><span class="line">//第一个键值对是foo: &apos;Hello&apos;，其中foo是“键名”（成员的名称），字符串Hello是“键值”（成员的值）</span><br><span class="line">//键名与键值之间用冒号分隔</span><br><span class="line">//两个键值对之间用逗号分隔</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，大括号定义了一个对象，被赋值给变量 <code>obj</code>，所以变量<code>obj</code>就指向一个对象。</p>
<h3 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h3><p>对象的所有键名都是字符串，所以加不加引号都可以。<br>日过键名是数值，会被自动转化为字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var  obj = &#123;</span><br><span class="line">  1: &apos;A&apos;，</span><br><span class="line">  1e2: true</span><br><span class="line">&#125;;</span><br><span class="line">obj[1] //A</span><br><span class="line">obj[&apos;1&apos;] //A</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象<code>obj</code>的键名虽然看上去像数值，实际上被自动转成了字符串。<br><strong>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符） 且也不是数字，则必须加上引号，否则会报错</strong><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  1p: &apos;Hello World&apos;</span><br><span class="line">&#125;;</span><br><span class="line">//报错</span><br><span class="line">var obj = &#123;</span><br><span class="line">  &apos;1p&apos;: &apos;Hello World&apos;,</span><br><span class="line">  &apos;h w&apos;: &apos;Hello World&apos;,</span><br><span class="line">  &apos;p+q&apos;: &apos;Hello World&apos;</span><br><span class="line">&#125;;</span><br><span class="line">//不报错</span><br></pre></td></tr></table></figure></p>
<p>不符合标识名条件的键名，必须加上引号。<br>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: function(x)&#123;</span><br><span class="line">    return 2 * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.p(1)</span><br><span class="line">//2</span><br></pre></td></tr></table></figure></p>
<p>如果属性的值还是一个对象就形成了链式引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = &#123;bar: &apos;hello&apos;&#125;;</span><br><span class="line"></span><br><span class="line">o1.foo = o2;</span><br><span class="line">o1.foo.bar</span><br><span class="line">//&apos;hello&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象<code>o1</code>的属性<code>foo</code>指向对象<code>o2</code>，就可以链式引用<code>o2</code>的属性。<br>属性可以动态创建，不必在对象声明时就指定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.foo = 123;</span><br><span class="line">obj.foo</span><br><span class="line">//123</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，直接对<code>obj</code>对象的<code>foo</code>属性赋值，结果就在运行时创建了<code>foo</code>属性。</p>
<h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有的变量。<br>如果取消某一个变量对于原对象的引用，不会影响到另一个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = o1;</span><br><span class="line"></span><br><span class="line">o1 = 1;</span><br><span class="line">o2 // &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，然后<code>o1</code>的值变为1，这时不会对<code>o2</code>产生影响，<code>o2</code>还是指向原来的那个对象。<br>但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">var y = x;</span><br><span class="line"></span><br><span class="line">x = 2;</span><br><span class="line">y // 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，当<code>x</code>的值发生变化后，<code>y</code>的值并不变，这就表示<code>y</code>和<code>x</code>并不是指向同一个内存地址。</p>
<h3 id="表达式还是语句"><a href="#表达式还是语句" class="headerlink" title="表达式还是语句"></a>表达式还是语句</h3><p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底时表达式还是语句？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;foo: 123&#125;</span><br></pre></td></tr></table></figure></p>
<p>JavaScript引擎读到上面这行代码，会发现可能有两种含义。第一种，这是一个表达式，表示一个包含<code>foo</code>属性的对象；第二种是，这是一个语句，表示一个代码区块，里面有一个<code>foo</code>标签，指向表达式123。<br><strong>为避免歧义，JavaScript规定，如果行首是大括号，一律解释为语句（代码块）。如果解释为表达式（对象），必须在大括号前加上圆括号。</strong></p>
<h3 id="读取属性"><a href="#读取属性" class="headerlink" title="读取属性"></a>读取属性</h3><p>读取对象属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: &apos;Hello World&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p // &quot;Hello World&quot;</span><br><span class="line">obj[&apos;p&apos;] // &quot;Hello World&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo = &apos;bar&apos;;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo  // 1</span><br><span class="line">obj[foo]  // 2</span><br></pre></td></tr></table></figure></p>
<p>方括号运算符内部还可以使用表达式。<br>数字键可以不加引号，因为会自动转成字符串。<br><strong>数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</strong></p>
<h3 id="属性的赋值"><a href="#属性的赋值" class="headerlink" title="属性的赋值"></a>属性的赋值</h3><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。<br>JavaScript允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候就定义好属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.p = 1;</span><br></pre></td></tr></table></figure></p>
<h3 id="查看所有属性"><a href="#查看所有属性" class="headerlink" title="查看所有属性"></a>查看所有属性</h3><p>查看一个对象本身所有的属性，可以用<code>Object.keys</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(obj);</span><br><span class="line">//obj为对象</span><br></pre></td></tr></table></figure></p>
<h3 id="delete-命令"><a href="#delete-命令" class="headerlink" title="delete 命令"></a>delete 命令</h3><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete obj.p</span><br><span class="line">//true</span><br><span class="line">//删除obj对象的p属性</span><br></pre></td></tr></table></figure></p>
<p><strong>删除一个不存在的属性，<code>delete</code>不报错，且返回<code>true</code>，所以不能根据<code>delete</code>命令的结果，认定某个属性是存在的。另，<code>delete</code>命令只能删除对象本身属性，无法删除继承的属性。</strong><br>（只有一种情况，<code>delete</code>命令返回<code>false</code>，那就是该元素存在，不得删除。）</p>
<h3 id="in-运算"><a href="#in-运算" class="headerlink" title="in 运算"></a>in 运算</h3><p><code>in</code>运算符用于检查对象是否包含某个属性（键名），如果包含就返回<code>true</code>，否则返回<code>false</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">&apos;p&apos; in obj // true</span><br></pre></td></tr></table></figure></p>
<p><code>in</code>运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些是继承的。</p>
<h3 id="for…in-循环"><a href="#for…in-循环" class="headerlink" title="for…in 循环"></a>for…in 循环</h3><p><code>for...in</code>循环用来遍历一个对象的全部属性。<br>下面是一个使用<code>for...in</code>循环，提取对象属性名的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  x: 1,</span><br><span class="line">  y: 2</span><br><span class="line">&#125;;</span><br><span class="line">var props = [];</span><br><span class="line">var i = 0;</span><br><span class="line"></span><br><span class="line">for (var p in obj) &#123;</span><br><span class="line">  props[i++] = p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">props // [&apos;x&apos;, &apos;y&apos;]</span><br></pre></td></tr></table></figure></p>
<p><strong>遍历的对象是所有可遍历的属性，会跳过不可遍历属性。（toString不可遍历）</strong><br><strong>不仅遍历自身的属性，还遍历继承的属性。</strong><br>结合<code>hasOwnProperty</code>方法使用，在循环内部判断一下，某个属性是否为自身属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.hasOwnProperty(key)</span><br></pre></td></tr></table></figure></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>数组是按照次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。<br>除了在定义时赋值，数组也可以先定义后赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line"></span><br><span class="line">arr[0] = &apos;a&apos;;</span><br><span class="line">arr[1] = &apos;b&apos;;</span><br><span class="line">arr[2] = &apos;c&apos;;</span><br></pre></td></tr></table></figure></p>
<p>任何类型的数据，都可以放入数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [</span><br><span class="line">  &#123;a: 1&#125;,</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  function() &#123;return true;&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>如果数组的元素还是数组，就形成了多维数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [[1, 2], [3, 4]];</span><br><span class="line">a[0][1] // 2</span><br><span class="line">a[1][1] // 4</span><br></pre></td></tr></table></figure></p>
<h3 id="数组的本质"><a href="#数组的本质" class="headerlink" title="数组的本质"></a>数组的本质</h3><p>本质上，数组属于一种特殊的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof [1, 2, 3] // &quot;object&quot;</span><br></pre></td></tr></table></figure></p>
<p>数组的特殊性体现在，它的键名是按照次序排列的一组整数（0，1，2。。。）。<br><strong>对于数值键名，不能使用点结构</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.0 // SyntaxError</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，arr.0的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号arr[0]表示（方括号是运算符，可以接受数值）。</p>
<h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><p>数组的<code>length</code>属性，返回数组成员数量。<br>只要是数组，就一定有<code>length</code>属性。<strong>该属性是一个动态的值，等于键名中最大整数加上1。</strong><br>数组是一种动态数据结构，可以随时增减数组成员。<br><code>length</code>属性是可写的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];</span><br><span class="line">arr.length // 3</span><br><span class="line"></span><br><span class="line">arr.length = 2;</span><br><span class="line">arr // [&quot;a&quot;, &quot;b&quot;]</span><br><span class="line">//该组成员自动减少到length设置的值</span><br></pre></td></tr></table></figure></p>
<p>清空数组的方法，可以将<code>length</code>属性设为0。<br><em>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。</em></p>
<h3 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h3><p>检查某个键名是够存在的运算符<code>in</code>，适用于对象，也适用于数组。</p>
<h3 id="for…in-循环和数组的遍历"><a href="#for…in-循环和数组的遍历" class="headerlink" title="for…in 循环和数组的遍历"></a>for…in 循环和数组的遍历</h3><p><code>for...in</code>循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。<br>但是，<code>for...in</code>不仅会遍历数组所有数字键，还会遍历非数字键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3];</span><br><span class="line">a.foo = true;</span><br><span class="line"></span><br><span class="line">for (var key in a) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// foo</span><br></pre></td></tr></table></figure></p>
<p>所以不推荐使用<code>for...in</code>遍历数组。<br>可以考虑使用<code>for</code>循环或者<code>while</code>循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">// for循环</span><br><span class="line">for(var i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">  console.log(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// while循环</span><br><span class="line">var i = 0;</span><br><span class="line">while (i &lt; a.length) &#123;</span><br><span class="line">  console.log(a[i]);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var l = a.length;</span><br><span class="line">while (l--) &#123;</span><br><span class="line">  console.log(a[l]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数组的<code>forEach</code>方法也可以用来遍历数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];</span><br><span class="line">colors.forEach(function (color) &#123;</span><br><span class="line">  console.log(color);</span><br><span class="line">&#125;);</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br></pre></td></tr></table></figure></p>
<h3 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h3><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, , 1];</span><br><span class="line">a.length // 3</span><br></pre></td></tr></table></figure></p>
<p>上面代码表明，数组的空位不影响length属性。<br>需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。<br>数组的空位是可以读取的，返回undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [, , ,];</span><br><span class="line">a[1] // undefined</span><br></pre></td></tr></table></figure></p>
<p>如果是空位，使用数组的forEach方法、for…in结构、以及Object.keys方法进行遍历，空位都会被跳过(undefined不会)。</p>
<h3 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h3><p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象很像数组，语法上称为“类数组对象”。<br>遍历：可以将“类数组对象”转为真正额数组，然后直接调用<code>forEach</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array.prototype.slice.call(&apos;abc&apos;);</span><br><span class="line">arr.forEach(function (chr) &#123;</span><br><span class="line">  console.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line">// a</span><br><span class="line">// b</span><br><span class="line">// c</span><br></pre></td></tr></table></figure></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是一段可以反复调用的代码块。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h4><p>JavaScript有三种声明函数的方法。<br>（1）function 命令<br>（2）函数表达式（采用变量赋值的写法）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var print = function(s) &#123;</span><br><span class="line">  console.log(s);</span><br><span class="line">&#125;;</span><br><span class="line">//此时匿名函数称为函数表达式</span><br></pre></td></tr></table></figure></p>
<p>（3）Function 构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var add = new Function(</span><br><span class="line">  &apos;x&apos;,</span><br><span class="line">  &apos;y&apos;,</span><br><span class="line">  &apos;return x + y&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不推荐此方法，了解即可。</p>
<h4 id="函数重复声明"><a href="#函数重复声明" class="headerlink" title="函数重复声明"></a>函数重复声明</h4><p>如果一个函数被多次声明，后面的声明就会覆盖前面的声明。</p>
<h4 id="圆括号运算符，return-语句和递归"><a href="#圆括号运算符，return-语句和递归" class="headerlink" title="圆括号运算符，return 语句和递归"></a>圆括号运算符，return 语句和递归</h4><p>调用函数时。要使用圆括号运算符。圆括号中加入函数参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 1) // 2</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。</p>
<p>函数体内部的<code>return</code>语句，表示返回。JavaScript 引擎遇到<code>return</code>语句，就直接返回<code>return</code>后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，<code>return</code>语句所带的那个表达式，就是函数的返回值。<code>return</code>语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回<code>undefined</code>。</p>
<p>函数调用自身就是递归（recursion）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//计算斐波那契数列</span><br><span class="line">function fib(num) &#123;</span><br><span class="line">  if (num === 0) return 0;</span><br><span class="line">  if (num === 1) return 1;</span><br><span class="line">  return fib(num - 2) + fib(num - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib(6) // 8</span><br><span class="line">//fib函数内部又调用了fib，计算得到斐波那契数列的第6个元素是8。</span><br></pre></td></tr></table></figure></p>
<h4 id="函数名的提升"><a href="#函数名的提升" class="headerlink" title="函数名的提升"></a>函数名的提升</h4><p>JavaScrip 引擎将函数名视同变量名，所以采用<code>function</code>命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br><span class="line"></span><br><span class="line">function f() &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于变量提升，函数<code>f</code>被提升到代码头部，所以不会报错。<br><strong>如果采用赋值语句定义函数，会报错</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br><span class="line">var f = function ()&#123;&#125;;</span><br><span class="line">// TypeError: undefined is not a function</span><br></pre></td></tr></table></figure></p>
<p>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var f;</span><br><span class="line">f();</span><br><span class="line">f = function () &#123;&#125;;</span><br><span class="line">//调用f时，f只是被声明，未赋值，等于undefined</span><br></pre></td></tr></table></figure></p>
<p><strong>所以如果同时采用<code>function</code>命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。</strong></p>
<h4 id="不能在条件语句总声明函数"><a href="#不能在条件语句总声明函数" class="headerlink" title="不能在条件语句总声明函数"></a>不能在条件语句总声明函数</h4><h3 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h3><h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><p>函数的name属性返回紧跟在function关键字之后的那个函数名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;&#125;</span><br><span class="line">f1.name // &apos;f1&apos;</span><br><span class="line">//函数的name属性总是返回紧跟在function关键字之后的那个函数名</span><br></pre></td></tr></table></figure></p>
<h4 id="length-属性-1"><a href="#length-属性-1" class="headerlink" title="length 属性"></a>length 属性</h4><p>函数的<code>length</code>属性返回函数预期传入的参数个数（定义的参数个数）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b) &#123;&#125;</span><br><span class="line">f.length // 2</span><br></pre></td></tr></table></figure></p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>函数的<code>toString()</code>方法返回一个字符串，内容是函数源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;/*</span><br><span class="line">  这是一个</span><br><span class="line">  多行注释</span><br><span class="line">*/</span><br><span class="line">  a();</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.toString()</span><br><span class="line">// function f() &#123;/*</span><br><span class="line">//   这是一个</span><br><span class="line">//   多行注释</span><br><span class="line">//*/</span><br><span class="line">//  a();</span><br><span class="line">//  b();</span><br><span class="line">//  c();</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>作用域指的是变量存在的范围。<br>全局作用域：变量在整个程序中一直存在，所有地方都可以读取（在函数外部声明）。<br>函数作用域：变量只在函数内部存在（在函数内部定义）。<br>块级作用域<br><strong>函数内部定义的变量，会在该作用域内覆盖同名全局变量。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var v = 1;</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">  var v = 2;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 2</span><br><span class="line">v // 1</span><br></pre></td></tr></table></figure></p>
<p><strong>注意，对于<code>var</code>命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  var x = 5;</span><br><span class="line">&#125;</span><br><span class="line">console.log(x);  // 5</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>x</code>在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。</p>
<h3 id="函数内部的变量提升"><a href="#函数内部的变量提升" class="headerlink" title="函数内部的变量提升"></a>函数内部的变量提升</h3><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。<code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体头部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(x) &#123;</span><br><span class="line">  if (x &gt; 100) &#123;</span><br><span class="line">    var tmp = x - 100;//可以理解为这一区块声明的全局变量</span><br><span class="line">  &#125;//在这个区块又成为局部变量，因为在函数体中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function foo(x) &#123;</span><br><span class="line">  var tmp;</span><br><span class="line">  if (x &gt; 100) &#123;</span><br><span class="line">    tmp = x - 100;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="函数本身的作用域"><a href="#函数本身的作用域" class="headerlink" title="函数本身的作用域"></a>函数本身的作用域</h4><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在作用域无关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var x = function () &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数<code>x</code>是在函数f的外部声明的，所以它的作用域绑定外层，内部变量<code>a</code>不会到函数<code>f</code>体内取值，所以输出<code>1</code>，而不是<code>2</code>。<br><strong>函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</strong><br><strong>同样，函数体内声明的函数，作用域绑定函数体内部。</strong></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>函数运行时，有时候需要提供外部数据，不同的外部数据会得到不同结果，这种外部数据就叫做参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function square(x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(2) // 4</span><br><span class="line">square(3) // 9</span><br></pre></td></tr></table></figure></p>
<p>参数可省略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b) &#123;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2, 3) // 1</span><br><span class="line">f(1) // 1</span><br><span class="line">f() // undefined</span><br><span class="line"></span><br><span class="line">f.length // 2</span><br></pre></td></tr></table></figure></p>
<h4 id="同名参数"><a href="#同名参数" class="headerlink" title="同名参数"></a>同名参数</h4><p>如果有同名参数，则取最后出现的那个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(a, a) &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2) // 2</span><br></pre></td></tr></table></figure></p>
<p>调用函数<code>f</code>时，没有提供第二个参数，<code>a</code>的值就变成了<code>undefined</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(a, a) &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1) // undefined</span><br></pre></td></tr></table></figure></p>
<h4 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h4><p>由于 JavaScript 允许函数有不定数目的参数。所以需要一种机制，可以在函数体内部读取所有参数，这就是<code>arguments</code>对象。<br><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。<br><strong>这个对象只有在函数体内部才能使用。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var f = function (one) &#123;</span><br><span class="line">  console.log(arguments[0]);</span><br><span class="line">  console.log(arguments[1]);</span><br><span class="line">  console.log(arguments[2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2, 3)</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure></p>
<p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  return arguments.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2, 3) // 3</span><br><span class="line">f(1) // 1</span><br><span class="line">f() // 0</span><br></pre></td></tr></table></figure></p>
<p>将<code>arguments</code>转为真正的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//slice方法</span><br><span class="line">var args = Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line">// 逐一填入数组</span><br><span class="line">var args = [];</span><br><span class="line">for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">  args.push(arguments[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h3><p>eval命令的作用是，将字符串当作语句执行。<br>（此处不做过多介绍）</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符"></a>加法运算符</h3><h4 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h4><ul>
<li>数值求和</li>
<li>布尔值转数值求和</li>
<li>字符串拼接</li>
</ul>
<p>运算子（数值，字符串）的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。<br>加法运算符存在重载，需注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;3&apos; + 4 + 5 // &quot;345&quot;</span><br><span class="line">3 + 4 + &apos;5&apos; // &quot;75&quot;</span><br></pre></td></tr></table></figure></p>
<p>由于由左到右运算，字符串的位置不同会导致不同的结果。<br><strong>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。</strong></p>
<h4 id="对象的相加"><a href="#对象的相加" class="headerlink" title="对象的相加"></a>对象的相加</h4><p>如果运算子是对象，必须先转成原始类型的值，然后再相加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">obj + 2 // &quot;[object Object]2&quot;</span><br></pre></td></tr></table></figure></p>
<p>对象转原始类型的值：</p>
<ol>
<li><p>调用对象valueOf方法（返回对象自身）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">obj.valueOf() // &#123; p: 1 &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用对象toString方法（转为字符串）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">obj.valueOf().toString() // &quot;[object Object]&quot;</span><br><span class="line">//对象的toString方法默认返回[object Object]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里有一个特例，如果运算子是一个Date对象的实例，那么会优先执行toString方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Date();</span><br><span class="line">obj.valueOf = function () &#123; return 1 &#125;;</span><br><span class="line">obj.toString = function () &#123; return &apos;hello&apos; &#125;;</span><br><span class="line"></span><br><span class="line">obj + 2 // &quot;hello2&quot;</span><br></pre></td></tr></table></figure></p>
<p>toString方法优先执行。</p>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><h4 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h4><p>运算结果的正负号由第一个运算子的正负号决定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 % 2 // -1</span><br><span class="line">1 % -2 // 1</span><br></pre></td></tr></table></figure></p>
<p>为了得到负数的正确余数值，可以先使用绝对值函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function isOdd(n) &#123;</span><br><span class="line">  return Math.abs(n % 2) === 1;</span><br><span class="line">&#125;</span><br><span class="line">isOdd(-5) // true</span><br><span class="line">isOdd(-4) // false</span><br></pre></td></tr></table></figure></p>
<h4 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h4><p>自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">var y = 1;</span><br><span class="line"></span><br><span class="line">x++ // 1</span><br><span class="line">++y // 2</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，x是先返回当前值，然后自增，所以得到1；y是先自增，然后返回新的值，所以得到2。</p>
<h4 id="数值运算符，负数值运算符"><a href="#数值运算符，负数值运算符" class="headerlink" title="数值运算符，负数值运算符"></a>数值运算符，负数值运算符</h4><p>数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+true // 1</span><br><span class="line">+[] // 0</span><br><span class="line">+&#123;&#125; // NaN</span><br></pre></td></tr></table></figure></p>
<p>负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">-x // -1</span><br><span class="line">-(-x) // 1</span><br></pre></td></tr></table></figure></p>
<p><strong>数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。</strong></p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><h4 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h4><p>字符串按照字典顺序进行比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;cat&apos; &gt; &apos;dog&apos; // false</span><br><span class="line">&apos;cat&apos; &gt; &apos;catalog&apos; // false</span><br></pre></td></tr></table></figure></p>
<p>JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。</p>
<h4 id="非字符串的比较"><a href="#非字符串的比较" class="headerlink" title="非字符串的比较"></a>非字符串的比较</h4><h5 id="原始类型的值"><a href="#原始类型的值" class="headerlink" title="原始类型的值"></a>原始类型的值</h5><p>两个原始类型的值的比较，除了相等运算符（==）和严格相等运算符（===），其他比较运算符都是先转成数值再比较。</p>
<p>任何值（包括NaN本身）与NaN比较，返回的都是false。</p>
<h5 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h5><p>如果运算子是对象，会转为原始类型的值，再进行比较。</p>
<h4 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符"></a>严格相等运算符</h4><p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v1 = &#123;&#125;;</span><br><span class="line">var v2 = v1;</span><br><span class="line">v1 === v2 // true</span><br></pre></td></tr></table></figure></p>
<p><strong>注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值</strong></p>
<p>undefined和null与自身严格相等。<br>undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。</p>
<p>由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的。</p>
<h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><h4 id="取反运算符"><a href="#取反运算符" class="headerlink" title="取反运算符"></a>取反运算符</h4><p>对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">!undefined // true</span><br><span class="line">!null // true</span><br><span class="line">!false //true</span><br><span class="line">!0 // true</span><br><span class="line">!NaN // true</span><br><span class="line">!&quot;&quot; // true</span><br><span class="line"></span><br><span class="line">!54 // false</span><br><span class="line">!&apos;hello&apos; // false</span><br><span class="line">![] // false</span><br><span class="line">!&#123;&#125; // false</span><br></pre></td></tr></table></figure></p>
<p>不管什么类型的值，经过取反运算后，都变成了布尔值。</p>
<h4 id="且运算符（-amp-amp-）"><a href="#且运算符（-amp-amp-）" class="headerlink" title="且运算符（&amp;&amp;）"></a>且运算符（&amp;&amp;）</h4><p>如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。</p>
<h4 id="或运算符（-）"><a href="#或运算符（-）" class="headerlink" title="或运算符（||）"></a>或运算符（||）</h4><p>如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。</p>
<p>或运算符常用于为一个变量设置默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function saveText(text) &#123;</span><br><span class="line">  text = text || &apos;&apos;;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者写成</span><br><span class="line">saveText(this.text || &apos;&apos;)</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。</p>
<h4 id="三元运算符（-）"><a href="#三元运算符（-）" class="headerlink" title="三元运算符（?:）"></a>三元运算符（?:）</h4><p>与<code>if...else...</code>的区别：<br>if…else是语句，没有返回值；三元条件表达式是表达式，具有返回值。<br>所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>记住所有运算符优先级，没有必要，查阅即可。</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>强制转换主要指使用Number、String和Boolean三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。</p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><p>Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;42 cats&apos;) // 42</span><br><span class="line">Number(&apos;42 cats&apos;) // NaN</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。<br>Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。</p>
<h4 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h4><p>String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String(&#123;a: 1&#125;) // &quot;[object Object]&quot;</span><br><span class="line">String([1, 2, 3]) // &quot;1,2,3&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h4><p>它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Boolean(undefined) // false</span><br><span class="line">Boolean(null) // false</span><br><span class="line">Boolean(0) // false</span><br><span class="line">Boolean(NaN) // false</span><br><span class="line">Boolean(&apos;&apos;) // false</span><br></pre></td></tr></table></figure></p>
<p><strong>所有对象的布尔值都是true</strong></p>
<h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><ul>
<li><p>不同类型的数据互相运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123 + &apos;abc&apos; // &quot;123abc&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非布尔值类型的数据求布尔值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (&apos;abc&apos;) &#123;</span><br><span class="line">  console.log(&apos;hello&apos;)</span><br><span class="line">&#125;  // &quot;hello&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对非数值类型的值使用一元运算符（即+和-）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ &#123;foo: &apos;bar&apos;&#125; // NaN</span><br><span class="line">- [1, 2, 3] // NaN</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。</p>
<ul>
<li><p>Object对象本身的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.print = function (o) &#123; console.log(o) &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object的实例方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义在Object原型对象Object.prototype上的方法</span><br><span class="line">Object.prototype.print = function () &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj = new Object();</span><br><span class="line">obj.print() // Object</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>obj直接继承了Object.prototype的属性和方法。也就是说，obj对象的print方法实质上就是调用Object.prototype.print方法。</p>
<p><strong>凡是定义在Object.prototype对象上面的属性和方法，将被所有实例对象共享</strong></p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object()"></a>Object()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object();</span><br><span class="line">obj instanceof Object // true</span><br></pre></td></tr></table></figure>
<p>obj instanceof Object返回true，就表示obj对象是Object的实例。</p>
<h3 id="Object-构造函数"><a href="#Object-构造函数" class="headerlink" title="Object 构造函数"></a>Object 构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br></pre></td></tr></table></figure>
<h3 id="Object-的静态方法"><a href="#Object-的静态方法" class="headerlink" title="Object 的静态方法"></a>Object 的静态方法</h3><p>遍历属性</p>
<ul>
<li><code>Object.keys()</code></li>
<li><code>Object.getOwnPropertyNames()</code></li>
</ul>
<p>原型链相关</p>
<ul>
<li><code>Object.create()</code></li>
<li><code>Object.getPrototypeOf()</code><br>其他方法这里不做介绍</li>
</ul>
<h3 id="Object-的实例方法"><a href="#Object-的实例方法" class="headerlink" title="Object 的实例方法"></a>Object 的实例方法</h3><p>定义在Object.prototype对象的方法，所有Object的实例对象都继承了这些方法。<br>主要有以下六个</p>
<ul>
<li><code>Object.prototype.valueOf()</code>：返回当前对象对应的值。</li>
<li><code>Object.prototype.toString()</code>：返回当前对象对应的字符串形式。</li>
<li><code>Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式。</li>
<li><code>Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li>
<li><code>Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型。</li>
<li><code>Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举。</li>
</ul>
<p><strong>Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.prototype.toString.call(obj) // &quot;[object Object]&quot;</span><br><span class="line">//第二个Object表示该值的构造函数</span><br></pre></td></tr></table></figure></p>
<p><strong>也就是说，Object.prototype.toString可以看出一个值到底是什么类型。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(2) // &quot;[object Number]&quot;</span><br><span class="line">Object.prototype.toString.call(&apos;&apos;) // &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;</span><br><span class="line">Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;</span><br><span class="line">Object.prototype.toString.call(null) // &quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(Math) // &quot;[object Math]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;) // &quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call([]) // &quot;[object Array]&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>利用这个特性，可以写出一个比<code>typeof</code>更准确的类型判断函数。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var type = function (o)&#123;</span><br><span class="line">  var s = Object.prototype.toString.call(o);</span><br><span class="line">  return s.match(/\[object (.*?)\]/)[1].toLowerCase();</span><br><span class="line">&#125;;</span><br><span class="line">type(&#123;&#125;); // &quot;object&quot;</span><br><span class="line">type([]); // &quot;array&quot;</span><br><span class="line">type(5); // &quot;number&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>生成新数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(2);</span><br><span class="line">arr.length // 2</span><br><span class="line">arr // [ undefined x 2 ]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Array构造函数的参数2，表示生成一个两个成员的数组，每个位置都是空值。</p>
<p>Array构造函数有一个很大的问题，就是不同的参数，会导致它的行为不一致。<br>因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var arr = new Array(1, 2);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var arr = [1, 2];</span><br></pre></td></tr></table></figure></p>
<h3 id="Arra-isArray"><a href="#Arra-isArray" class="headerlink" title="Arra.isArray()"></a>Arra.isArray()</h3><p>判断一个值是否为数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3];</span><br><span class="line">Array.isArray(a) // true</span><br></pre></td></tr></table></figure></p>
<h3 id="Array实例的方法"><a href="#Array实例的方法" class="headerlink" title="Array实例的方法"></a>Array实例的方法</h3><ul>
<li><p><code>valueOf()</code>：返回数组本身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3];</span><br><span class="line">a.valueOf() // [1, 2, 3]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toString()</code>：返回数组的字符串形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3];</span><br><span class="line">a.toString() // &quot;1,2,3&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>push()</code>：在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度（该方法会改变原数组）</p>
</li>
<li><code>pop()</code>：删除数组的最后一个元素（该方法会改变原数组）</li>
<li><p><code>join()</code>：以参数作为分隔符，将所有数组成员组成一个字符串返回（如果不提供参数，默认用逗号分隔）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">a.join(&apos; &apos;) // &apos;1 2 3 4&apos;</span><br><span class="line">a.join(&apos; | &apos;) // &quot;1 | 2 | 3 | 4&quot;</span><br><span class="line">a.join() // &quot;1,2,3,4&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>concat()</code>：多个数组的合并，将新数组的成员，添加到原数组成员的后部，然后返回一个新数组（原数组不变）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].concat(4, 5, 6)</span><br><span class="line">// [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>shift()</code>：删除数组的第一个元素，并返回该元素（该方法会改变原数组）</p>
</li>
<li><code>unshift()</code>：在数组的第一个位置添加元素，并返回添加新元素后的数组长度（该方法会改变原数组）</li>
<li><code>reverse()</code>：颠倒数组中元素的顺序，返回改变后的数组（该方法将改变原数组)</li>
<li><code>slice()</code>：提取原数组的一部分，返回一个新数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">arr.slice(start_index, stop_index);</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">a.slice(0) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">a.slice(1) // [&quot;b&quot;, &quot;c&quot;]</span><br><span class="line">a.slice(1, 2) // [&quot;b&quot;]</span><br><span class="line">a.slice(2, 6) // [&quot;c&quot;]</span><br><span class="line">a.slice() // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果slice方法的参数是负数，则表示倒数计算的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">a.slice(-2) // [&quot;b&quot;, &quot;c&quot;]</span><br><span class="line">a.slice(-2, -1) // [&quot;b&quot;]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>splice()</code>：删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素（该方法会改变原数组）</li>
</ul>
<p>splice的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">arr.splice(index, count_to_remove, addElement1, addElement2, ...);</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];</span><br><span class="line">a.splice(4, 2, 1, 2) // [&quot;e&quot;, &quot;f&quot;]</span><br><span class="line">a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2]</span><br></pre></td></tr></table></figure></p>
<p>起始位置如果是负数，就表示从倒数位置开始删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];</span><br><span class="line">a.splice(-4, 2) // [&quot;c&quot;, &quot;d&quot;]</span><br></pre></td></tr></table></figure></p>
<p>如果只是单纯地插入元素，splice方法的第二个参数可以设为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 1, 1];</span><br><span class="line"></span><br><span class="line">a.splice(1, 0, 2) // []</span><br><span class="line">a // [1, 2, 1, 1]</span><br></pre></td></tr></table></figure></p>
<p>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3, 4];</span><br><span class="line">a.splice(2) // [3, 4]</span><br><span class="line">a // [1, 2]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>sort()</code>：对数组成员进行排序，默认是按照字典顺序排序（原数组将被改变）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;d&apos;, &apos;c&apos;, &apos;b&apos;, &apos;a&apos;].sort()</span><br><span class="line">// [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>sort方法不是按照大小排序，而是按照对应字符串的字典顺序排序</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[10111, 1101, 111].sort()</span><br><span class="line">// [10111, 1101, 111]</span><br></pre></td></tr></table></figure></p>
<p>如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[10111, 1101, 111].sort(function (a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;)</span><br><span class="line">// [111, 1101, 10111]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>map()</code>：对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">numbers.map(function (n) &#123;</span><br><span class="line">  return n + 1;</span><br><span class="line">&#125;);</span><br><span class="line">// [2, 3, 4]</span><br><span class="line"></span><br><span class="line">numbers</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。</p>
<ul>
<li><code>forEach()</code>：遍历数组的所有成员，不返回值，只用来操作数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function log(element, index, array) &#123;</span><br><span class="line">  console.log(&apos;[&apos; + index + &apos;] = &apos; + element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[2, 5, 9].forEach(log);</span><br><span class="line">// [0] = 2</span><br><span class="line">// [1] = 5</span><br><span class="line">// [2] = 9</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>forEach方法不会跳过undefined和null，但会跳过空位。</p>
<ul>
<li><p><code>filter</code>：filter方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].filter(function (elem) &#123;</span><br><span class="line">  return (elem &gt; 3);</span><br><span class="line">&#125;)</span><br><span class="line">// [4, 5]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>some()</code>，<code>every()</code>：判断数组成员是否符合某种条件<br><code>some</code>方法是只要有一个数组成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则<code>false</code>。<br><code>every</code>方法则是所有数组成员的返回值都是<code>true</code>，才返回<code>true</code>，否则<code>false</code>。</p>
</li>
<li><code>reduce()</code>，<code>reduceRight()</code></li>
<li><code>indexOf()</code>：返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1</li>
<li><code>lastIndexOf()</code>：返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1<br><strong>注意，如果数组中包含NaN，这两个方法不适用，即无法确定数组成员是否包含NaN。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN) // -1</span><br><span class="line">[NaN].lastIndexOf(NaN) // -1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><h3 id="包装对象的定义"><a href="#包装对象的定义" class="headerlink" title="包装对象的定义"></a>包装对象的定义</h3><p>所谓“包装对象”，就是使用构造函数（new）将以下三个原始类型的值转为对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v1 = new Number(123);</span><br><span class="line">var v2 = new String(&apos;abc&apos;);</span><br><span class="line">var v3 = new Boolean(true);</span><br></pre></td></tr></table></figure></p>
<p>生成的对象与原始值的类型不同。这用typeof运算符就可以看出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeof v1 // &quot;object&quot;</span><br><span class="line">typeof v2 // &quot;object&quot;</span><br><span class="line">typeof v3 // &quot;object&quot;</span><br><span class="line"></span><br><span class="line">v1 === 123 // false</span><br><span class="line">v2 === &apos;abc&apos; // false</span><br><span class="line">v3 === true // false</span><br></pre></td></tr></table></figure></p>
<p>通过设计包装对象，可以方便原始类型的值调用特定的方法。</p>
<p>Number、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number(123) // 123</span><br><span class="line">String(&apos;abc&apos;) // &quot;abc&quot;</span><br><span class="line">Boolean(true) // true</span><br></pre></td></tr></table></figure></p>
<h3 id="包装对象实例的方法"><a href="#包装对象实例的方法" class="headerlink" title="包装对象实例的方法"></a>包装对象实例的方法</h3><p>包装对象实例可以使用Object对象提供的原生方法，主要是<code>valueOf</code>和<code>toString</code>方法。</p>
<ul>
<li><p><code>valueOf</code>：返回包装对象实例对应的原始类型的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Number(123).valueOf()  // 123</span><br><span class="line">new String(&quot;abc&quot;).valueOf() // &quot;abc&quot;</span><br><span class="line">new Boolean(&quot;true&quot;).valueOf() // true</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toString()</code>：返回实例对应的字符串形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Number(123).toString() // &quot;123&quot;</span><br><span class="line">new String(&quot;abc&quot;).toString() // &quot;abc&quot;</span><br><span class="line">new Boolean(&quot;true&quot;).toString() // &quot;true&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="原始类型的自动转换"><a href="#原始类型的自动转换" class="headerlink" title="原始类型的自动转换"></a>原始类型的自动转换</h3><p>比如，字符串调用<code>length</code>属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.length // 3</span><br></pre></td></tr></table></figure></p>
<p>JavaScript引擎自动将其转为包装对象，在这个对象上调用length属性。</p>
<p>除了<code>valueOf</code>和<code>toString</code>方法，还包括包装对象各自定义在原型上的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.charAt === String.prototype.charAt</span><br><span class="line">// true</span><br><span class="line">//定义在String对象原型上的方法</span><br></pre></td></tr></table></figure></p>
<h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><p>包装对象还可以在原型上添加自定义方法和属性，供原始类型的值直接调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.double = function () &#123;</span><br><span class="line">  return this.valueOf() + this.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&apos;abc&apos;.double()</span><br><span class="line">// abcabc</span><br><span class="line"></span><br><span class="line">Number.prototype.double = function () &#123;</span><br><span class="line">  return this.valueOf() + this.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(123).double()</span><br><span class="line">// 246</span><br></pre></td></tr></table></figure></p>
<p><strong>这种自定义方法和属性的机制，只能定义在包装对象的原型上，如果直接对原始类型的变量添加属性，则无效。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;abc&apos;;</span><br><span class="line"></span><br><span class="line">s.p = 123;</span><br><span class="line">s.p // undefined</span><br><span class="line">//包装对象是自动生成的，赋值后自动销毁</span><br></pre></td></tr></table></figure></p>
<h3 id="Boolean-对象"><a href="#Boolean-对象" class="headerlink" title="Boolean 对象"></a>Boolean 对象</h3><p>主要用于生成布尔值的包装对象的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var b = new Boolean(true);</span><br><span class="line"></span><br><span class="line">typeof b // &quot;object&quot;</span><br><span class="line">b.valueOf() // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码的变量b是一个Boolean对象的实例，它的类型是对象，值为布尔值true。（此方法几乎无人使用，了解原理即可）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//此方法更加直观清晰</span><br><span class="line">var b = true;</span><br></pre></td></tr></table></figure></p>
<h2 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h2><p>Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。</p>
<ul>
<li><p>构造函数的使用，生成值为数值的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var n = new Number(1);</span><br><span class="line">typeof n // &quot;object&quot;</span><br><span class="line">//返回一个值为1的对象</span><br></pre></td></tr></table></figure>
</li>
<li><p>工具函数的使用，将任何类型的值转为数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number(true) // 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Number-对象实例的方法"><a href="#Number-对象实例的方法" class="headerlink" title="Number 对象实例的方法"></a>Number 对象实例的方法</h3><ul>
<li><code>Number.prototype.toString()</code>：将数值转为字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(10).toString() // &quot;10&quot;</span><br><span class="line">等同于</span><br><span class="line">10[&apos;toString&apos;](2) // &quot;1010&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>toString</code>接受一个参数，表示输出的进制（默认十进制）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(10).toString(2) // &quot;1010&quot;</span><br><span class="line">(10).toString(8) // &quot;12&quot;</span><br><span class="line">(10).toString(16) // &quot;a&quot;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>Number.prototype.toFixed()</code>：将一个数转为指定位数的小数，返回这个小数对应的字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(10).toFixed(2) // &quot;10.00&quot;</span><br><span class="line">10.005.toFixed(2) // &quot;10.01&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>10.005就不用放在括号里，第一个点被解释为小数点，第二个点就只能解释为点运算符。<br><strong>参数为指定的小数位数，有效范围为0到20，超出这个范围将抛出RangeError错误。</strong></p>
<ul>
<li><code>Number.prototype.toExponential()</code>：将一个数转为科学计数法形式</li>
<li><code>Number.prototype.toPrecision()</code>：将一个数转为指定位数的有效数字</li>
</ul>
<h3 id="自定义方法-1"><a href="#自定义方法-1" class="headerlink" title="自定义方法"></a>自定义方法</h3><p>与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number.prototype.add = function (x) &#123;</span><br><span class="line">  return this + x;</span><br><span class="line">&#125;;</span><br><span class="line">8[&apos;add&apos;](2) // 10</span><br><span class="line">等同于</span><br><span class="line">(8).add(2) // 10</span><br></pre></td></tr></table></figure></p>
<p>上面代码为Number对象实例定义了一个add方法。</p>
<p>由于add方法返回的还是数值，所以可以链式运算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number.prototype.subtract = function (x) &#123;</span><br><span class="line">  return this - x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(8).add(2).subtract(4)</span><br><span class="line">// 6</span><br></pre></td></tr></table></figure></p>
<p>在Number对象的原型上部署了iterate方法，将一个数值自动遍历为一个数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Number.prototype.iterate = function () &#123;</span><br><span class="line">  var result = [];</span><br><span class="line">  for (var i = 0; i &lt;= this; i++) &#123;</span><br><span class="line">    result.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(8).iterate()</span><br><span class="line">// [0, 1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure></p>
<p><strong>数值的自定义方法，只能定义在它的原型对象Number.prototype上面，数值本身是无法自定义属性的。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var n = 1;</span><br><span class="line">n.x = 1;</span><br><span class="line">n.x // undefined</span><br></pre></td></tr></table></figure></p>
<h2 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h2><p>String对象是JavaScript原生提供的三个包装对象之一，用来生成字符串的包装对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s1 = &apos;abc&apos;;</span><br><span class="line">var s2 = new String(&apos;abc&apos;);</span><br><span class="line"></span><br><span class="line">typeof s1 // &quot;string&quot;</span><br><span class="line">typeof s2 // &quot;object&quot;</span><br><span class="line"></span><br><span class="line">s2.valueOf() // &quot;abc&quot;</span><br></pre></td></tr></table></figure></p>
<p>实际上，字符串的包装对象是一个类似数组的对象（即很像数组，但是实质上不是数组）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;abc&quot;)</span><br><span class="line">// String &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3&#125;</span><br></pre></td></tr></table></figure></p>
<p>String对象的工具方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String(true) // &quot;true&quot;</span><br><span class="line">String(5) // &quot;5&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="Strng-fromCharCode"><a href="#Strng-fromCharCode" class="headerlink" title="Strng.fromCharCode()"></a>Strng.fromCharCode()</h3><p>该方法的参数是一系列Unicode码点，返回对应的字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode(104, 101, 108, 108, 111)</span><br><span class="line">// &quot;hello&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="实例对象的属性和方法"><a href="#实例对象的属性和方法" class="headerlink" title="实例对象的属性和方法"></a>实例对象的属性和方法</h3><ul>
<li><code>length</code>属性：length属性返回字符串的长度</li>
<li><code>charAt()</code>：charAt方法返回指定位置的字符，参数是从0开始编号的位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = new String(&apos;abc&apos;);</span><br><span class="line"></span><br><span class="line">s.charAt(1) // &quot;b&quot;</span><br><span class="line">s.charAt(s.length - 1) // &quot;c&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个方法完全可以用数组下标代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.charAt(1) // &quot;b&quot;</span><br><span class="line">&apos;abc&apos;[1] // &quot;b&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果参数为负数，或大于等于字符串的长度，charAt返回空字符串。</p>
<ul>
<li><p><code>charCodeAt()</code>：返回给定位置字符的Unicode码点（十进制表示），相当于String.fromCharCode()的逆操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.charCodeAt(1) // 98</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>concat()</code>：连接两个字符串，返回一个新字符串，不改变原字符串</p>
</li>
<li><code>slice()</code>：用于从原字符串取出子字符串并返回，不改变原字符串</li>
<li><code>substring()</code>：用于从原字符串取出子字符串并返回，不改变原字符串（不建议使用，建议使用<code>slice()</code>）</li>
<li><code>substr()</code>：用于从原字符串取出子字符串并返回，不改变原字符串</li>
<li><code>indexOf()，lastIndexOf()</code>：用于确定一个字符串在另一个字符串中的位置，都返回一个整数，表示匹配开始的位置</li>
<li><code>trim()</code>：用于去除字符串两端的空格，返回一个新字符串，不改变原字符串</li>
<li><p><code>toLowerCase()，toUpperCase()</code>：用于将一个字符串全部转为小写，大写，返回一个新字符串，不改变原字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;Hello World&apos;.toLowerCase()</span><br><span class="line">// &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">&apos;Hello World&apos;.toUpperCase()</span><br><span class="line">// &quot;HELLO WORLD&quot;</span><br><span class="line"></span><br><span class="line">String.prototype.toUpperCase.call([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br><span class="line">// &apos;A,B,C&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>localeCompare()</code>：用于比较两个字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;apple&apos;.localeCompare(&apos;banana&apos;)</span><br><span class="line">// -1</span><br><span class="line"></span><br><span class="line">&apos;apple&apos;.localeCompare(&apos;apple&apos;)</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面方法返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</p>
<ul>
<li><p><code>match()</code>：用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;cat, bat, sat, fat&apos;.match(&apos;at&apos;) // [&quot;at&quot;]</span><br><span class="line">&apos;cat, bat, sat, fat&apos;.match(&apos;xt&apos;) // null</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>search()</code>：用法等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;cat, bat, sat, fat&apos;.search(&apos;at&apos;) // 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replace()</code>：用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;aaa&apos;.replace(&apos;a&apos;, &apos;b&apos;) // &quot;baa&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>split()</code>：按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;a|b|c&apos;.split(&apos;|&apos;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">&apos;a|b|c&apos;.split(&apos;&apos;) // [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>split方法还可以接受第二个参数，限定返回数组的最大成员数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a|b|c&apos;.split(&apos;|&apos;, 1) // [&quot;a&quot;]</span><br></pre></td></tr></table></figure></p>
<h2 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h2><p><code>Math</code>是JavaScript的内置对象，提供一系列数学方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Math()</span><br><span class="line">// TypeError: object is not a function</span><br></pre></td></tr></table></figure></p>
<p><strong><code>Math</code> 不能当作构造函数使用</strong><br><code>Math</code> 对象提供一些只读数字常数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">Math.E：常数e</span><br><span class="line">Math.LN2：2的自然对数</span><br><span class="line">Math.LN10：10的自然对数</span><br><span class="line">Math.LOG2E：以2为底的e的对数</span><br><span class="line">Math.LOG10E：以10为底的e的对数</span><br><span class="line">Math.PI：常数Pi</span><br><span class="line">Math.SQRT1_2：0.5的平方根</span><br><span class="line">Math.SQRT2：2的平方根</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>Math</code> 对象提供一些数学方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">Math.abs()：绝对值</span><br><span class="line">Math.ceil()：向上取整</span><br><span class="line">Math.floor()：向下取整</span><br><span class="line">Math.max()：最大值</span><br><span class="line">Math.min()：最小值</span><br><span class="line">Math.pow()：指数运算</span><br><span class="line">Math.sqrt()：平方根</span><br><span class="line">Math.log()：自然对数</span><br><span class="line">Math.exp()：e的指数</span><br><span class="line">Math.round()：四舍五入</span><br><span class="line">Math.random()：随机数</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>Math.random()</code>：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random() // 0.7151307314634323</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以写一个任意范围的随机数生成函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getRandom(min, max)&#123;</span><br><span class="line">    return Math.random() * (max - min) + min</span><br><span class="line">&#125;</span><br><span class="line">getRandom(1.5, 6.5)</span><br><span class="line">// 2.4942810038223864</span><br></pre></td></tr></table></figure></p>
<p>还可以写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getRandom(min, max)&#123;</span><br><span class="line">    return Math.floor(Math.radom() * (max -min + 1)) + min</span><br><span class="line">&#125;</span><br><span class="line">getRandom(1, 6)</span><br><span class="line">//5</span><br></pre></td></tr></table></figure></p>
<p>返回一个随机字符的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function random_str(length) &#123;</span><br><span class="line">  var ALPHABET = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;;</span><br><span class="line">  ALPHABET += &apos;abcdefghijklmnopqrstuvwxyz&apos;;</span><br><span class="line">  ALPHABET += &apos;0123456789-_&apos;;</span><br><span class="line">  var str = &apos;&apos;;</span><br><span class="line">  for (var i=0; i &lt; length; ++i) &#123;</span><br><span class="line">    var rand = Math.floor(Math.random() * ALPHABET.length);</span><br><span class="line">    str += ALPHABET.substring(rand, rand + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">random_str(6) // &quot;NdQKOr&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h3><p><code>Math</code> 对象还提供一系列三角函数方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">Math.sin()：返回参数的正弦</span><br><span class="line">Math.cos()：返回参数的余弦</span><br><span class="line">Math.tan()：返回参数的正切</span><br><span class="line">Math.asin()：返回参数的反正弦（弧度值）</span><br><span class="line">Math.acos()：返回参数的反余弦（弧度值）</span><br><span class="line">Math.atan()：返回参数的反正切（弧度值）</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Date-对象"><a href="#Date-对象" class="headerlink" title="Date 对象"></a>Date 对象</h2><p><code>Date</code>对象是 JavaScript 提供的日期和时间的操作接口。<br><img src="https://i.loli.net/2018/01/20/5a631288266b7.png" alt="作为普通函数直接调用"><br><strong>无论有没有参数，直接调用<code>Date</code>总是返回当前时间</strong></p>
<h3 id="new-Date"><a href="#new-Date" class="headerlink" title="new Date()"></a>new Date()</h3><p><code>Date</code>还可以作为构造函数使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var today = new Date();</span><br></pre></td></tr></table></figure></p>
<h3 id="日期的运算"><a href="#日期的运算" class="headerlink" title="日期的运算"></a>日期的运算</h3><p>类型转换时，<code>Date</code>对象的实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。（相减返回毫秒数，相加返回拼接字符串）</p>
<h3 id="Date对象的静态方法"><a href="#Date对象的静态方法" class="headerlink" title="Date对象的静态方法"></a><code>Date</code>对象的静态方法</h3><ul>
<li><code>Date.now()</code>：返回当前距离1970年1月1日 00:00:00 UTC 的毫秒数</li>
<li><code>Date.parse()</code>：解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数</li>
<li><code>Date.UTC</code>：返回 UTC 时间（）世界标准时间。</li>
</ul>
<h3 id="Date-实例对象的方法"><a href="#Date-实例对象的方法" class="headerlink" title="Date 实例对象的方法"></a><a href="http://javascript.ruanyifeng.com/stdlib/date.html" target="_blank" rel="noopener">Date 实例对象的方法</a></h3><h2 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h2><p>正则表达式（regular expression），通常用来匹配文本。比如，Email地址。<br>新建正则表达式有两种方法：</p>
<ul>
<li><p>使用字面量，以斜杠开始和结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regex = /xyz/;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RegExp 构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regex = new RegExp(&apos;xyz&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>RegExp 构造函数接收第二个参数，修饰符<code>i</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = new RegExp(&apos;xyz&apos;, &quot;i&quot;);</span><br><span class="line">// 等价于</span><br><span class="line">var regex = /xyz/i;</span><br></pre></td></tr></table></figure></p>
<p>以上两种写法有一个细微区别。采用字面量写法，正则对象在代码载入时生成；采用构造函数写法，正则对象在代码运行时生成。（通常使用字面量写法）</p>
<h3 id="正则对象的属性和方法"><a href="#正则对象的属性和方法" class="headerlink" title="正则对象的属性和方法"></a>正则对象的属性和方法</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var r = /abc/igm;</span><br><span class="line"></span><br><span class="line">r.ignoreCase // true</span><br><span class="line">r.global // true</span><br><span class="line">r.multiline // true</span><br></pre></td></tr></table></figure>
</li>
<li><p>lastIndex：返回下一次开始搜索的位置。</p>
</li>
<li>source：返回正则表达式字符串形式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var r = /abc/igm;</span><br><span class="line"></span><br><span class="line">r.lastIndex // 0</span><br><span class="line">r.source // &quot;abc&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h4><p>返回一个布尔值，表示当前模式是否能匹配参数字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/cat/.test(&apos;cats and dogs&apos;) // true</span><br></pre></td></tr></table></figure></p>
<p> 如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置向后匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var r = /x/g;</span><br><span class="line">var s = &apos;_x_x&apos;;</span><br><span class="line"></span><br><span class="line">r.lastIndex // 0</span><br><span class="line">r.test(s) // true</span><br><span class="line"></span><br><span class="line">r.lastIndex // 2</span><br><span class="line">r.test(s) // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码每一次搜索的位置都是上一次匹配的后一个位置。</p>
<p>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var r = /x/g;</span><br><span class="line">var s = &apos;_x_x&apos;;</span><br><span class="line"></span><br><span class="line">r.lastIndex = 4;</span><br><span class="line">r.test(s) // false</span><br></pre></td></tr></table></figure></p>
<p>上面代码指定从字符串的第五个位置开始搜索，这个位置没有字符，所以返回 <code>false</code>。</p>
<p><strong>如果正则模式是一个空字符串，则匹配所有字符串。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new RegExp(&apos;&apos;).test(&apos;abc&apos;)</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<h4 id="exce"><a href="#exce" class="headerlink" title="exce()"></a>exce()</h4><p>将匹配结果返回一个数组，否则返回<code>null</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;_x_x&apos;;</span><br><span class="line">var r1 = /x/;</span><br><span class="line">var r2 = /y/;</span><br><span class="line"></span><br><span class="line">r1.exec(s) // [&quot;x&quot;]</span><br><span class="line">r2.exec(s) // null</span><br></pre></td></tr></table></figure></p>
<p>如果正则对象是一个空字符串，则<code>exec</code>方法会匹配成功，但返回的也是空字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var r1 = new RegExp(&apos;&apos;);</span><br><span class="line">var a1 = r1.exec(&apos;abc&apos;);</span><br><span class="line">a1 // [&apos;&apos;]</span><br><span class="line">a1.index // 0</span><br><span class="line">r1.lastIndex // 0</span><br></pre></td></tr></table></figure></p>
<h3 id="字符串对象的方法"><a href="#字符串对象的方法" class="headerlink" title="字符串对象的方法"></a>字符串对象的方法</h3><h4 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h4><p>返回一个数组，成员是所有匹配的字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;_x_x&apos;;</span><br><span class="line">var r1 = /x/;</span><br><span class="line">var r2 = /y/;</span><br><span class="line"></span><br><span class="line">s.match(r1) // [&quot;x&quot;]</span><br><span class="line">s.match(r2) // null</span><br></pre></td></tr></table></figure></p>
<p>该方法与<code>exce</code>方法非常类似。</p>
<p>如果正则表达式带有<code>g</code>修饰符，则与<code>exce</code>不同，会一次性返回所有匹配成功的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;abba&apos;;</span><br><span class="line">var r = /a/g;</span><br><span class="line"></span><br><span class="line">s.match(r) // [&quot;a&quot;, &quot;a&quot;]</span><br><span class="line">r.exec(s) // [&quot;a&quot;]</span><br></pre></td></tr></table></figure></p>
<h4 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search()"></a>String.prototype.search()</h4><p>返回第一个匹配结果在整个字符串中的位置。若无匹配，返回<code>-1</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;_x_x&apos;.search(/x/)</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<h4 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h4><p>按照给定的正则表达式进行替换，返回替换后的字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(search, replacement)</span><br></pre></td></tr></table></figure></p>
<p>搜索模式如果不加<code>g</code> 修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;aaa&apos;.replace(&apos;a&apos;, &apos;b&apos;) // &quot;baa&quot;</span><br><span class="line">&apos;aaa&apos;.replace(/a/g, &apos;b&apos;) // &quot;bbb&quot;</span><br></pre></td></tr></table></figure></p>
<p>消除字符串首尾两端空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;  #id div.class  &apos;;</span><br><span class="line"></span><br><span class="line">str.replace(/^\s+|\s+$/g, &apos;&apos;)</span><br><span class="line">// &quot;#id div.class&quot;</span><br></pre></td></tr></table></figure></p>
<p>replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;3 and 5&apos;.replace(/[0-9]+/g, function(match)&#123;</span><br><span class="line">  return 2 * match;</span><br><span class="line">&#125;)</span><br><span class="line">// &quot;6 and 10&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h4><p>按照正则规则分割字符串，返回数组。<br>接受两个参数，分隔规则和返回数组的最大成员数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 非正则分隔</span><br><span class="line">&apos;a,  b,c, d&apos;.split(&apos;,&apos;)</span><br><span class="line">// [ &apos;a&apos;, &apos;  b&apos;, &apos;c&apos;, &apos; d&apos; ]</span><br><span class="line"></span><br><span class="line">// 正则分隔，去除多余的空格</span><br><span class="line">&apos;a,  b,c, d&apos;.split(/, */)</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ]</span><br><span class="line"></span><br><span class="line">// 指定返回数组的最大成员</span><br><span class="line">&apos;a,  b,c, d&apos;.split(/, */, 2)</span><br><span class="line">[ &apos;a&apos;, &apos;b&apos; ]</span><br></pre></td></tr></table></figure></p>
<p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格。</p>
<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a><a href="http://javascript.ruanyifeng.com/stdlib/regexp.html" target="_blank" rel="noopener">匹配规则</a></h3><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>表示模式的附加规则，放在正则模式的最尾部。<br>修饰符可单个使用，也可多个一起使用。</p>
<ul>
<li><code>g</code>修饰符：表示全局匹配，匹配全部符合条件的结果。</li>
<li><p><code>i</code>修饰符：正则对象默认区分大小写，加上<code>i</code>修饰符后表示忽略大小写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/abc/.test(&apos;ABC&apos;) // false</span><br><span class="line">/abc/i.test(&apos;ABC&apos;) // true</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>m</code>修饰符：表示多行模式。默认情况<code>^</code>和<code>$</code>匹配字符串的开始和结尾处，加上<code>m</code>修饰符后，<code>^</code>和<code>$</code>还会匹配行首行尾（识别换行符）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/world$/.test(&apos;hello world\n&apos;) // false</span><br><span class="line">/world$/m.test(&apos;hello world\n&apos;) // true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>看另一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^b/m.test(&apos;a\nb&apos;) // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码要求匹配行首是<code>b</code>，加上<code>m</code>修饰符，可识别换行符，<code>b</code>在行首，返回<code>true</code>。</p>
<h4 id="组匹配"><a href="#组匹配" class="headerlink" title="组匹配"></a>组匹配</h4><p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/fred+/.test(&apos;fredd&apos;) // true</span><br><span class="line">/(fred)+/.test(&apos;fredfred&apos;) // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码，第一个匹配重复字母<code>d</code>，第二个表示匹配”fred”这个词。</p>
<p>匹配网页标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var tagName = /&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/;</span><br><span class="line"></span><br><span class="line">tagName.exec(&quot;&lt;b&gt;bold&lt;/b&gt;&quot;)[1]</span><br><span class="line">// &apos;b&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，圆括号匹配尖括号之中的标签，而\1就表示对应的闭合标签。</p>
<p>略加修改，就能捕获带有属性的标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var html = &apos;&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;&apos;;</span><br><span class="line">var tag = /&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g;</span><br><span class="line"></span><br><span class="line">var match = tag.exec(html);</span><br><span class="line"></span><br><span class="line">match[1] // &quot;b&quot;</span><br><span class="line">match[2] // &quot;class=&quot;hello&quot;&quot;</span><br><span class="line">match[3] // &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">match = tag.exec(html);</span><br><span class="line"></span><br><span class="line">match[1] // &quot;i&quot;</span><br><span class="line">match[2] // &quot;&quot;</span><br><span class="line">match[3] // &quot;world&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h2><p>JSON 格式：</p>
<ul>
<li>书写简单，一目了然</li>
<li>符合 JavaScript 原生语法，由解释器引擎直接处理。<h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3>用于将一个值转为字符串。该字符串符合<br>JSON 格式，能够被<code>JSON.parse</code>方法还原。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&apos;abc&apos;) // &quot;&quot;abc&quot;&quot;</span><br><span class="line">JSON.stringify(1) // &quot;1&quot;</span><br><span class="line">JSON.stringify(false) // &quot;false&quot;</span><br><span class="line">JSON.stringify([]) // &quot;[]&quot;</span><br><span class="line">JSON.stringify(&#123;&#125;) // &quot;&#123;&#125;&quot;</span><br><span class="line"></span><br><span class="line">JSON.stringify([1, &quot;false&quot;, false])</span><br><span class="line">// &apos;[1,&quot;false&quot;,false]&apos;</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; name: &quot;张三&quot; &#125;)</span><br><span class="line">// &apos;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>对于原始类型的字符串，转换结果会带双引号</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&apos;foo&apos;) === &quot;foo&quot; // false</span><br><span class="line">JSON.stringify(&apos;foo&apos;) === &quot;\&quot;foo\&quot;&quot; // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，字符串foo，被转成了””foo””。这是因为将来还原的时候，双引号可以让 JavaScript 引擎知道，foo是一个字符串，而不是一个变量名。</p>
<p>如果原始对象中，有一个成员值是<code>undefined</code>、函数或 XML<br>对象，这个成员会被过滤。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  a: undefined,</span><br><span class="line">  b: function () &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JSON.stringify(obj) // &quot;&#123;&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果数组成员是<code>undefined</code>、函数或 XML 对象，则这些值被转成<code>null</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [undefined, function () &#123;&#125;];</span><br><span class="line">JSON.stringify(arr) // &quot;[null,null]&quot;</span><br></pre></td></tr></table></figure></p>
<p>正则对象会被转成空对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(/foo/) // &quot;&#123;&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="JSON-stringify-的第二个参数"><a href="#JSON-stringify-的第二个参数" class="headerlink" title="JSON.stringify() 的第二个参数"></a>JSON.stringify() 的第二个参数</h4><p>可以是一个函数，更改<code>JSON.stringify</code>的默认行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(key, value) &#123;</span><br><span class="line">  if (typeof value === &quot;number&quot;) &#123;</span><br><span class="line">    value = 2 * value;</span><br><span class="line">  &#125;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; a: 1, b: 2 &#125;, f)</span><br><span class="line">// &apos;&#123;&quot;a&quot;: 2,&quot;b&quot;: 4&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>递归处理所有的键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;a: &#123;b: 1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">function f(key, value) &#123;</span><br><span class="line">  console.log(&quot;[&quot;+ key +&quot;]:&quot; + value);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSON.stringify(o, f)</span><br><span class="line">// []:[object Object]</span><br><span class="line">// [a]:[object Object]</span><br><span class="line">// [b]:1</span><br><span class="line">// &apos;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象o一共会被f函数处理三次。第一次键名为空，键值是整个对象o；第二次键名为a，键值是{b: 1}；第三次键名为b，键值为1。</p>
<h3 id="toJSON-方法"><a href="#toJSON-方法" class="headerlink" title="toJSON 方法"></a>toJSON 方法</h3><p>将正则对象自动转为字符串（JSON.stringify默认不能转换正则对象，但是设置了toJSON方法以后，就可以转换正则对象了）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  reg: /foo/</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 不设置 toJSON 方法时</span><br><span class="line">JSON.stringify(obj) // &quot;&#123;&quot;reg&quot;:&#123;&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">// 设置 toJSON 方法时</span><br><span class="line">RegExp.prototype.toJSON = RegExp.prototype.toString;</span><br><span class="line">JSON.stringify(/foo/) // &quot;&quot;/foo/&quot;&quot;</span><br></pre></td></tr></table></figure></p>
<p>在正则对象的原型上部署<code>toJSON</code>方法，将其指向<code>toString</code>方法。因此当遇到转换成 JSON 时，就会先调用<code>toJSON</code>转为字符串，在被<code>JSON.stringify</code>处理。</p>
<h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h3><p>JSON.parse方法用于将JSON字符串转化成对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(&apos;&#123;&#125;&apos;) // &#123;&#125;</span><br><span class="line">JSON.parse(&apos;true&apos;) // true</span><br><span class="line">JSON.parse(&apos;&quot;foo&quot;&apos;) // &quot;foo&quot;</span><br><span class="line">JSON.parse(&apos;[1, 5, &quot;false&quot;]&apos;) // [1, 5, &quot;false&quot;]</span><br><span class="line">JSON.parse(&apos;null&apos;) // null</span><br><span class="line"></span><br><span class="line">var o = JSON.parse(&apos;&#123;&quot;name&quot;: &quot;张三&quot;&#125;&apos;);</span><br><span class="line">o.name // 张三</span><br></pre></td></tr></table></figure></p>
<p>结合<code>JSON.stringify()</code>和<code>JSON.parse()</code>方法可以实现对一个对象的深拷贝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var source = &#123;</span><br><span class="line">    name:&quot;source&quot;,</span><br><span class="line">    child:&#123;</span><br><span class="line">        name:&quot;child&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var target = JSON.parse(JSON.stringify(source));</span><br><span class="line">target.name = &quot;target&quot;; //改变target的name属性</span><br><span class="line">console.log(source.name);   //source</span><br><span class="line">console.log(target.name);   //target</span><br><span class="line">target.child.name = &quot;target child&quot;; //改变target的child</span><br><span class="line">console.log(source.child.name);  //child</span><br><span class="line">console.log(target.child.name);  //target child</span><br></pre></td></tr></table></figure></p>
<p>赋值后的<code>target</code>和<code>source</code>二者不会互相影响。但是<code>JSON.stringify()</code>默认不能转换正则对象，需要再次结合<code>toJSON</code>方法。</p>
<h2 id="console-对象"><a href="#console-对象" class="headerlink" title="console 对象"></a><a href="http://javascript.ruanyifeng.com/stdlib/console.html" target="_blank" rel="noopener">console 对象</a></h2><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="构造函数与-new-命令"><a href="#构造函数与-new-命令" class="headerlink" title="构造函数与 new 命令"></a>构造函数与 new 命令</h2><h3 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h3><p>面向对象编程将各种复杂的关系抽象为对象，再对其进行操作。</p>
<p>所有事物都可以是对象，事物之间存在的种种联系建立了面向对象编程的基础。</p>
<p>属性是对于对象的描述，方法是对象的行为。比如，可以将动物抽象成<code>animal</code>对象，使用“属性”描述是哪一种动物，使用“方法”表示动物的行为（奔跑）。</p>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>面向对象编程的第一步就是要生成对象。</p>
<p>我们可以通过一个模板来生成具有共同特征的的对象。</p>
<p>JavaScript 语言是基于构造函数和原型链。这个构造函数就是上句话所说的模板，是专门用来生成对象的函数。</p>
<p>这个构造函数，提供模板描述对象的基本结构，这样就能生成多个具有相同结构的对象，这些对象也成为实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle = function () &#123;</span><br><span class="line">  this.price = 1000;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Vehicle就是构造函数，它提供模板，用来生成实例对象。为了与普通函数区别，构造函数名字的第一个字母通常大写。<br>构造函数的特点：</p>
<ul>
<li>函数体内部使用<code>this</code>关键字，代表了所要生成的对象实例</li>
<li>生成对象的时候，必须使用<code>new</code>命令，调用构造函数</li>
</ul>
<h3 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a>new 命令</h3><p><code>new</code>命令的作用就是执行构造函数，返回一个实例对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle = function () &#123;</span><br><span class="line">  this.price = 1000;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var v = new Vehicle();</span><br><span class="line">v.price // 1000</span><br></pre></td></tr></table></figure></p>
<p>上面代码生成一个实例对象保存在变量<code>v</code>中。这个新生成的实例对象，继承了<code>price</code>属性。<code>new</code>命令执行时，构造函数内部额<code>this</code>，代表了新生成的实例对象，<code>this.price</code>表示实例对象有一个<code>price</code>属性，值是1000。<br>构造函数也可以接受参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle = function (p) &#123;</span><br><span class="line">  this.price = p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var v = new Vehicle(500);</span><br></pre></td></tr></table></figure></p>
<p><code>new</code>命令本身就可以执行构造函数，所以后面的括号可省略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v = new Vehicle();</span><br><span class="line">//等价于</span><br><span class="line">var v = new Vehicle;</span><br></pre></td></tr></table></figure></p>
<p>如果忘记使用<code>new</code>命令，直接调用构造函数。构造函数会变成普通函数，并不会生成实例，而<code>this</code>此时代表全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle = function ()&#123;</span><br><span class="line">  this.price = 1000;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var v = Vehicle();</span><br><span class="line">v.price</span><br><span class="line">// Uncaught TypeError: Cannot read property &apos;price&apos; of undefined</span><br><span class="line"></span><br><span class="line">price</span><br><span class="line">// 1000</span><br></pre></td></tr></table></figure></p>
<p>上面代码，<code>price</code>属性变成了全局变量，而变量<code>v</code>变成了<code>undefined</code>。<br>因此为避免以上情况，可以在构造函数内部使用严格模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fubar(foo, bar)&#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  this._foo = foo;</span><br><span class="line">  this._bar = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fubar()</span><br><span class="line">// TypeError: Cannot set property &apos;_foo&apos; of undefined</span><br></pre></td></tr></table></figure></p>
<p>由于在严格模式中，函数内部的<code>this</code>不能指向全局对象，默认等于<code>undefined</code>导致不加<code>new</code>会报错。</p>
<h4 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h4><ol>
<li>创建一个空对象，作为将要返回的对象实例</li>
<li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性</li>
<li>将这个空对象赋值给函数内部的<code>this</code>关键字</li>
<li>开始执行构造函数内部的代码<br>也就是说，构造函数内部，<code>this</code>指的是一个新生成的空对象，所有针对<code>this</code>的操作都会发生在这个空对象上。</li>
</ol>
<p>构造函数的目的，就是为了操作<code>this</code>，将其变成期望的样子。</p>
<p>如果构造函数内部有<code>return</code>语句，而且<code>return</code>后面跟着一个对象，<code>new</code>命令会返回<code>return</code>语句指定的对象；否则返回<code>this</code>对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle = function ()&#123;</span><br><span class="line">  this.price = 1000;</span><br><span class="line">  return &#123; price: 2000 &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(new Vehicle()).price</span><br><span class="line">// 2000</span><br></pre></td></tr></table></figure></p>
<p>如果普通函数（内部没有<code>this</code>关键字的函数）使用<code>new</code>命令，则会返回一个空对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getMessage() &#123;</span><br><span class="line">  return &apos;this is a message&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var msg = new getMessage();</span><br><span class="line"></span><br><span class="line">msg // &#123;&#125;</span><br><span class="line">typeof msg // &quot;object&quot;</span><br></pre></td></tr></table></figure></p>
<p>判断函数调用时，是否使用<code>new</code>命令：<br>使用<code>new.target</code>属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  console.log(new.target === f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // false</span><br><span class="line">new f() // true</span><br><span class="line">使用new，返回true</span><br></pre></td></tr></table></figure></p>
<p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  if (!new.target) &#123;</span><br><span class="line">    throw new Error(&apos;请使用 new 命令调用！&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // Uncaught Error: 请使用 new 命令调用！</span><br></pre></td></tr></table></figure></p>
<h4 id="使用-Object-create-创建实例对象"><a href="#使用-Object-create-创建实例对象" class="headerlink" title="使用 Object.create() 创建实例对象"></a>使用 Object.create() 创建实例对象</h4><p>以一个不是构造函数生成的实例对象为模板，生成一个新的实例对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person1 = &#123;</span><br><span class="line">  name: &apos;张三&apos;,</span><br><span class="line">  age: 38,</span><br><span class="line">  greeting: function() &#123;</span><br><span class="line">    console.log(&apos;Hi! I\&apos;m &apos; + this.name + &apos;.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person2 = Object.create(person1);</span><br><span class="line"></span><br><span class="line">person2.name // 张三</span><br><span class="line">person2.greeting() // Hi! I&apos;m 张三.</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象<code>person1</code>是<code>person2</code>的模板，后者继承了前者的属性和方法。</p>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p><code>this</code>总是返回一个对象，就是返回属性或方法“当前”所在的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: &apos;张三&apos;,</span><br><span class="line">  describe: function () &#123;</span><br><span class="line">    return &apos;姓名：&apos;+ this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.describe()</span><br><span class="line">// &quot;姓名：张三&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码，<code>this</code>指向当前对象，也就是<code>person</code>。</p>
<p>函数f内部使用了this关键字，随着f所在的对象不同，this的指向也不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  return &apos;姓名：&apos;+ this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var A = &#123;</span><br><span class="line">  name: &apos;张三&apos;,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B = &#123;</span><br><span class="line">  name: &apos;李四&apos;,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.describe() // &quot;姓名：张三&quot;</span><br><span class="line">B.describe() // &quot;姓名：李四&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果一个函数在全局环境中运行，那么<code>this</code>就是指顶层对象（浏览器中为<code>window</code>对象）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() === window // true</span><br></pre></td></tr></table></figure></p>
<p><strong><code>this</code>是所有函数运行时的一个隐藏参数，指向函数运行环境。</strong></p>
<h3 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h3><h4 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h4><p>在全局环境使用this，它指的就是顶层对象window。</p>
<h4 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数中的this，指的是实例对象。</p>
<h4 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h4><p>将某个对象的方法赋值给另一个对象，会改变this的指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj =&#123;</span><br><span class="line">  foo: function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo() // obj</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，obj.foo方法执行时，它内部的this指向obj。<br>但是，只有这一种用法（直接在obj对象上调用foo方法），this指向obj；其他用法时，this都指向代码块当前所在对象（浏览器为window对象）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 情况一</span><br><span class="line">(obj.foo = obj.foo)() // window</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line">(false || obj.foo)() // window</span><br><span class="line"></span><br><span class="line">// 情况三</span><br><span class="line">(1, obj.foo)() // window</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，obj.foo先运算再执行，即使值根本没有变化，this也不再指向obj了。这是因为这时它就脱离了运行环境obj，而是在全局环境执行。</p>
<p>如果某个方法位于多层对象的内部，这时<code>this</code>只是指向当前一层的对象，而不会继承更上面的层。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  p: &apos;Hello&apos;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: function() &#123;</span><br><span class="line">      console.log(this.p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.b.m() // undefined</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>a.b.m</code>方法在<code>a</code>对象的第二层，该方法内部的<code>this</code>不是指向<code>a.b</code>。<br>如果要达到预期效果，只有写成下面这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: function() &#123;</span><br><span class="line">      console.log(this.p);</span><br><span class="line">    &#125;,</span><br><span class="line">    p: &apos;Hello&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><h4 id="避免多层this"><a href="#避免多层this" class="headerlink" title="避免多层this"></a>避免多层this</h4><p>由于<code>this</code>的指向不确定，所以勿在函数中包含多层的<code>this</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  f1: function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    var f2 = function () &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f1()</span><br><span class="line">// Object</span><br><span class="line">// Window</span><br></pre></td></tr></table></figure></p>
<p>上面代码实际上是执行下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var temp = function () &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">  f1: function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    var f2 = temp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解决方法，在第二层改用一个指向外层<code>this</code>的变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  f1: function() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    var that = this;</span><br><span class="line">    var f2 = function() &#123;</span><br><span class="line">      console.log(that);</span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f1()</span><br><span class="line">// Object</span><br><span class="line">// Object</span><br></pre></td></tr></table></figure></p>
<p>这样就不会改变<code>this</code>的指向。<br><strong>使用一个变量固定<code>this</code>的值，然后内层函数调用这个变量</strong></p>
<h4 id="避免数组处理方法中的this"><a href="#避免数组处理方法中的this" class="headerlink" title="避免数组处理方法中的this"></a>避免数组处理方法中的this</h4><p>数组的<code>map</code>和<code>foreach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用<code>this</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  v: &apos;hello&apos;,</span><br><span class="line">  p: [ &apos;a1&apos;, &apos;a2&apos; ],</span><br><span class="line">  f: function f() &#123;</span><br><span class="line">    this.p.forEach(function (item) &#123;</span><br><span class="line">      console.log(this.v + &apos; &apos; + item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line">// undefined a1</span><br><span class="line">// undefined a2</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>foreach</code>方法的回掉函数中的<code>this</code>，其实是指<code>window</code>对象，因此取不到<code>o.v</code>的值。因为内层的<code>this</code>不指向外部，而指向顶层对象。</p>
<p>解决方法，使用中间变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  v: &apos;hello&apos;,</span><br><span class="line">  p: [ &apos;a1&apos;, &apos;a2&apos; ],</span><br><span class="line">  f: function f() &#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    this.p.forEach(function (item) &#123;</span><br><span class="line">      console.log(that.v+&apos; &apos;+item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line">// hello a1</span><br><span class="line">// hello a2</span><br></pre></td></tr></table></figure></p>
<p>另一种解决方法，将<code>this</code>当作<code>foreach</code>方法的第二个参数，固定它的运行环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  v: &apos;hello&apos;,</span><br><span class="line">  p: [ &apos;a1&apos;, &apos;a2&apos; ],</span><br><span class="line">  f: function f() &#123;</span><br><span class="line">    this.p.forEach(function (item) &#123;</span><br><span class="line">      console.log(this.v + &apos; &apos; + item);</span><br><span class="line">    &#125;, this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line">// hello a1</span><br><span class="line">// hello a2</span><br></pre></td></tr></table></figure></p>
<h4 id="避免回调函数中的this"><a href="#避免回调函数中的this" class="headerlink" title="避免回调函数中的this"></a>避免回调函数中的<code>this</code></h4><p>回调函数中的<code>this</code>往往会改变指向，最好避免使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object();</span><br><span class="line"></span><br><span class="line">o.f = function () &#123;</span><br><span class="line">  console.log(this === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f() // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示，如果调用<code>o</code>对象的 f 方法，其中<code>this</code>就是指向<code>o</code>对象。<br>但是，如果将<code>f</code>方法指定给某个按钮的<code>click</code>事件，this的指向就变了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#button&apos;).on(&apos;click&apos;, o.f);</span><br></pre></td></tr></table></figure></p>
<p>点击按钮后，控制台会显示<code>false</code>，原因是此时<code>this</code>不再指向<code>o</code>对象，而是指向按钮的DOM对象，因为<code>f</code>方法是在按钮对象的环境中被调用。</p>
<h3 id="绑定-this-的方法"><a href="#绑定-this-的方法" class="headerlink" title="绑定 this 的方法"></a>绑定 this 的方法</h3><h4 id="function-prototype-call"><a href="#function-prototype-call" class="headerlink" title="function.prototype.call()"></a>function.prototype.call()</h4><p>可以指定函数内部<code>this</code>的指向（函数执行时所在作用域），然后在所指定的作用域中，调用该函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var f = function () &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f() === this // true</span><br><span class="line">f.call(obj) === obj // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码在全局环境下运行<code>f</code>时，<code>this</code>指向全局环境；<code>call</code>方法，将<code>this</code>指向对象<code>obj</code>，这样就能在对象<code>obj</code>的作用域中运行函数<code>f</code>。<br><code>call</code>方法的参数应该是一个对象。如果参数为空、<code>null</code>和<code>undefined</code>则默认传入全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var n = 123;</span><br><span class="line">var obj = &#123; n: 456 &#125;;</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">  console.log(this.n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.call() // 123</span><br><span class="line">a.call(null) // 123</span><br><span class="line">a.call(undefined) // 123</span><br><span class="line">a.call(window) // 123</span><br><span class="line">a.call(obj) // 456</span><br></pre></td></tr></table></figure></p>
<p>上面代码，如果用<code>call</code>方法将<code>this</code>关键字指向<code>obj</code>对象，则在<code>obj</code>中调用<code>this</code>，返回456。</p>
<p><code>call</code>方法还可以接受多个参数。<br><code>func.call(thisValue, arg1, arg2, ...)</code><br><code>call</code>的第一个参数就是<code>this</code>所要指向的那个对象，后面的参数则是函数调用是所需的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.call(this, 1, 2) // 3</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>call</code>方法指定函数<code>add</code>内部的<code>this</code>绑定当前环境。</p>
<p><code>call</code>方法的一个应用是调用对象的原生方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.hasOwnProperty(&apos;toString&apos;) // false</span><br><span class="line"></span><br><span class="line">// 覆盖掉继承的 hasOwnProperty 方法</span><br><span class="line">obj.hasOwnProperty = function () &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;;</span><br><span class="line">obj.hasOwnProperty(&apos;toString&apos;) // true</span><br><span class="line"></span><br><span class="line">Object.prototype.hasOwnProperty.call(obj, &apos;toString&apos;) // false</span><br></pre></td></tr></table></figure></p>
<p>上面代码将<code>hasOwnProperty</code>方法的<strong>原始定义</strong>放到<code>obj</code>对象上执行，这样不论<code>obj</code>上面有没有同名方法，都不会影响结果。</p>
<h4 id="function-prototype-apply"><a href="#function-prototype-apply" class="headerlink" title="function.prototype.apply()"></a>function.prototype.apply()</h4><p><code>apply</code>方法与<code>call</code>方法类似，区别是接受一个数组作为函数执行时的参数。<br><code>func.apply(thisValue, [arg1, arg2, ...])</code><br>第一个参数也是<code>this</code>所指向的那个对象，如果设为 null 或 undefined ，则等于指定全局对象。第二个参数是一个数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f(x,y)&#123;</span><br><span class="line">  console.log(x+y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.call(null,1,1) // 2</span><br><span class="line">f.apply(null,[1,1]) // 2</span><br></pre></td></tr></table></figure></p>
<p>可以使用<code>apply</code>方法做一些扩展</p>
<ul>
<li><p>找出数组最大元素<br>结合使用<code>apply</code>方法和<code>Math.max</code>方法，返回数组最大元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [10, 2, 4, 15, 9];</span><br><span class="line"></span><br><span class="line">Math.max.apply(null, a)</span><br><span class="line">// 15</span><br></pre></td></tr></table></figure>
</li>
<li><p>将数组的空元素变为undefined<br>通过<code>apply</code>方法，利用Array构造函数将数组的空元素变成undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.apply(null, [&quot;a&quot;,,&quot;b&quot;])</span><br><span class="line">// [ &apos;a&apos;, undefined, &apos;b&apos; ]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，但是不会跳过<code>undefined</code>。</p>
<ul>
<li>转换类数组对象<br>另外，利用数组的<code>slice</code>方法，可以将类数组对象转为真正的数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.apply(&#123;0:1,length:1&#125;)</span><br><span class="line">// [1]</span><br><span class="line"></span><br><span class="line">Array.prototype.slice.apply(&#123;0:1&#125;)</span><br><span class="line">// []</span><br><span class="line"></span><br><span class="line">Array.prototype.slice.apply(&#123;0:1,length:2&#125;)</span><br><span class="line">// [1, undefined]</span><br><span class="line"></span><br><span class="line">Array.prototype.slice.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码的<code>apply</code>方法参数都是对象，但是返回结果都是数组，这就达到了对象转数组的目的。前提是，被处理对象必须有length属性，以及对应数字键。</p>
<ul>
<li>绑定回调函数的对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object();</span><br><span class="line"></span><br><span class="line">o.f = function () &#123;</span><br><span class="line">  console.log(this === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = function ()&#123;</span><br><span class="line">  o.f.apply(o);</span><br><span class="line">  // 或者 o.f.call(o);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(&apos;#button&apos;).on(&apos;click&apos;, f);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数</p>
<h4 id="function-prototype-bind"><a href="#function-prototype-bind" class="headerlink" title="function.prototype.bind()"></a>function.prototype.bind()</h4><p><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。<br><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象返回一个新函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d.getTime() // 1481869925657</span><br><span class="line"></span><br><span class="line">var print = d.getTime;</span><br><span class="line">print() // Uncaught TypeError: this is not a Date object.</span><br></pre></td></tr></table></figure></p>
<p>上面代码调用<code>print()</code>时报错，因为<code>getTime</code>方法内部的<code>this</code>绑定<code>Date</code>对象的实例，赋值给<code>print</code>以后，内部的<code>this</code>已经不指向<code>Date</code>对象实例了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var print = d.getTime.bind(d);</span><br><span class="line">print() // 1481869925657</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>bind</code>方法将<code>getTime</code>方法内部的<code>this</code>绑定到<code>d</code>对象，这样就可以安全的将这个方法赋值给其他变量了。</p>
<p><code>bind</code>方法除了绑定<code>this</code>之外，还可以绑定原函数的参数。<br>如果<code>bind</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象，函数运行时<code>this</code>指向顶层对象（在浏览器中为window）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var plus5 = add.bind(null, 5);</span><br><span class="line">plus5(10) // 15</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数<code>add</code>内部并没有<code>this</code>，使用<code>bind</code>方法的主要目的是绑定参数<code>x</code>，以后每次运行新函数<code>plus5</code>，就只需要提供另一个参数<code>y</code>就够了。</p>
<p><code>bind</code>方法有一些使用注意点</p>
<ul>
<li>每一次返回一个新函数<br>bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&apos;click&apos;, o.m.bind(o));</span><br><span class="line">element.removeEventListener(&apos;click&apos;, o.m.bind(o));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码中，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。</p>
<p>正确的方法是写成下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var listener = o.m.bind(o);</span><br><span class="line">element.addEventListener(&apos;click&apos;, listener);</span><br><span class="line">//  ...</span><br><span class="line">element.removeEventListener(&apos;click&apos;, listener);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><a href="http://javascript.ruanyifeng.com/oop/this.html" target="_blank" rel="noopener">结合回调函数使用</a></li>
<li><a href="http://javascript.ruanyifeng.com/oop/this.html" target="_blank" rel="noopener">结合call方法使用</a><h2 id="prototype对象"><a href="#prototype对象" class="headerlink" title="prototype对象"></a>prototype对象</h2>JavaScript语言的继承是通过“原型对象”（prototype）实现的。<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><h4 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h4>JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。可以在构造函数内部定义实例的属性和方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Cat (name, color) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cat1 = new Cat(&apos;大毛&apos;, &apos;白色&apos;);</span><br><span class="line"></span><br><span class="line">cat1.name // &apos;大毛&apos;</span><br><span class="line">cat1.color // &apos;白色&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码中，<code>Cat</code>就是一个构造函数，所有的实例对象（cat1）都会继承构造函数的属性和方法。</p>
<p>但是，同一个构造函数的实例之间，无法共享属性，每新建一个实例，就生成了同样的属性和方法，浪费系统资源。</p>
<p>我们需要一个方法，把这些完全相同的属性，共享起来。就是JavaScript的原型对象（prototype）。</p>
<h4 id="prototype-属性的作用"><a href="#prototype-属性的作用" class="headerlink" title="prototype 属性的作用"></a>prototype 属性的作用</h4><p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">typeof f.prototype // &quot;object&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数<code>f</code>默认具有<code>prototype</code>属性，指向一个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.color = &apos;white&apos;;</span><br><span class="line"></span><br><span class="line">var cat1 = new Animal(&apos;大毛&apos;);</span><br><span class="line">var cat2 = new Animal(&apos;二毛&apos;);</span><br><span class="line"></span><br><span class="line">cat1.color // &apos;white&apos;</span><br><span class="line">cat2.color // &apos;white&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面代码，构造函数<code>Animal</code>的<code>prototype</code>属性，就是实例对象<code>cat1</code>和<code>cat2</code>的原型对象。原型对象上添加了<code>color</code>属性，所有实例对象都共享了该属性。</p>
<p>就是因为原型对象的属性是共享的，所以只要更改原型对象，变动就会体现在所有实例对象上。</p>
<p>因为实例对象本身没有<code>color</code>这个属性，它就会去原型对象上读取<code>color</code>属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象上找该属性或方法。</p>
<p>但是，如果实例对昂本身就有某个属性或方法，它就不会再到原型上寻找了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat1.color = &apos;black&apos;;</span><br><span class="line"></span><br><span class="line">cat1.color // &apos;black&apos;</span><br><span class="line">cat2.color // &apos;white&apos;</span><br><span class="line">Animal.prototype.color // &apos;white&apos;;</span><br></pre></td></tr></table></figure></p>
<p>所以说，原型对象的作用就是为实例对象提供一些共有的方法和属性。这些被定义子在原型上的方法可以被所有对象实例调用。</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>JavaScript规定，所有对象都有自己的原型对象（prototype）。而原型对象也是对象，所以它也有自己的原型。因此，就会形成一“原型链”。</p>
<p>一层一层向上追溯，会发现所有对象的原型最终会找到<code>Object.prototype</code>，也就是<code>Object</code>构造函数的<code>prototype</code>属性。所有对象都继承了<code>Object.prototype</code>的属性。这就是为什么所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这都是从<code>Object.prototype</code>继承的。</p>
<p>那么<code>Object.prototype</code>对象有没有原型呢？<br><code>Object.prototype</code>的原型是null。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(Object.prototype)</span><br><span class="line">// null</span><br></pre></td></tr></table></figure></p>
<p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。</p>
<h4 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h4><p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function P() &#123;&#125;</span><br><span class="line">P.prototype.constructor === P // true</span><br></pre></td></tr></table></figure></p>
<p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function P() &#123;&#125;</span><br><span class="line">var p = new P();</span><br><span class="line"></span><br><span class="line">p.constructor === P // true</span><br><span class="line">p.constructor === P.prototype.constructor // true</span><br><span class="line">p.hasOwnProperty(&apos;constructor&apos;) // false</span><br></pre></td></tr></table></figure></p>
<p>上面代码，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>本身没有<code>constructor</code>属性，但是可以通过原型链调用<code>P.prototype.constructor</code>属性。</p>
<p><code>constructor</code>属性的作用是，可以得知某个实例对象到底是由哪一个构造函数产生的。<br>通过这个特性我们可以从一个实例对象新建另一个实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Constr() &#123;&#125;</span><br><span class="line">var x = new Constr();</span><br><span class="line"></span><br><span class="line">var y = new x.constructor();</span><br><span class="line">y instanceof Constr // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码，从<code>x.constructor</code>间接调用构造函数。</p>
<p>constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor === Person // true</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  method: function () &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor === Person // false</span><br><span class="line">Person.prototype.constructor === Object // true</span><br></pre></td></tr></table></figure></p>
<p>可以看到上面代码，直接修改了<code>Person</code>的原型对象，却没有连同<code>constructor</code>属性一起修改，导致这个属性不再指向<code>Person</code>，而是指向新原型。这个新原型只是一个普通对象，它的<code>constructor</code>指向Object构造函数，导致<code>Person.prototype.constructor</code>变成了Object。<br>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 坏的写法</span><br><span class="line">C.prototype = &#123;</span><br><span class="line">  method1: function (...) &#123; ... &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 好的写法</span><br><span class="line">C.prototype = &#123;</span><br><span class="line">  constructor: C,</span><br><span class="line">  method1: function (...) &#123; ... &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 更好的写法</span><br><span class="line">C.prototype.method1 = function (...) &#123; ... &#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，要么将constructor属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证instanceof运算符不会失真。</p>
<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var v = new Vehicle();</span><br><span class="line">v instanceof Vehicle // true</span><br></pre></td></tr></table></figure></p>
<p>instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v instanceof Vehicle</span><br><span class="line">// 等同于</span><br><span class="line">Vehicle.prototype.isPrototypeOf(v)</span><br></pre></td></tr></table></figure></p>
<p>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d instanceof Date // true</span><br><span class="line">d instanceof Object // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，d同时是Date和Object的实例，因此对这两个构造函数都返回true。</p>
<p><code>instanceof</code>运算符的一个用处，是判断值的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = [1, 2, 3];</span><br><span class="line">var y = &#123;&#125;;</span><br><span class="line">x instanceof Array // true</span><br><span class="line">y instanceof Object // true</span><br></pre></td></tr></table></figure></p>
<p><strong>注意，instanceof运算符只能用于对象，不适用原始类型的值。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line">s instanceof String // false</span><br></pre></td></tr></table></figure></p>
<p>利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fubar (foo, bar) &#123;</span><br><span class="line">  if (this instanceof Fubar) &#123;</span><br><span class="line">    this._foo = foo;</span><br><span class="line">    this._bar = bar;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return new Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码使用instanceof运算符，在函数体内部判断this关键字是否为构造函数Fubar的实例。如果不是，就表明忘了加new命令。</p>
<h2 id="Object-对象的相关方法"><a href="#Object-对象的相关方法" class="headerlink" title="Object 对象的相关方法"></a>Object 对象的相关方法</h2><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>Object.getPrototypeOf方法返回参数对象的原型。这是获取原型对象的标准方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var F = function () &#123;&#125;;</span><br><span class="line">var f = new F();</span><br><span class="line">Object.getPrototypeOf(f) === F.prototype // true</span><br><span class="line"></span><br><span class="line">// 空对象的原型是 Object.prototype</span><br><span class="line">Object.getPrototypeOf(&#123;&#125;) === Object.prototype // true</span><br><span class="line"></span><br><span class="line">// Object.prototype 的原型是 null</span><br><span class="line">Object.getPrototypeOf(Object.prototype) === null // true</span><br><span class="line"></span><br><span class="line">// 函数的原型是 Function.prototype</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">Object.getPrototypeOf(f) === Function.prototype // true</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>Object.setPrototypeOf方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;;</span><br><span class="line">var b = &#123;x: 1&#125;;</span><br><span class="line">Object.setPrototypeOf(a, b);</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(a) === b</span><br><span class="line">a.x // 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码，将<code>a</code>的原型设置为<code>b</code>，这样<code>a</code>就可以调用<code>b</code>的属性和方法。</p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>除了使用new命令生成实例，还可以使用<code>Object.creat()</code>由一个实例对象生成另一个实例对象<br>该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。（该实例完全继承原型对象的属性）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 原型对象</span><br><span class="line">var A = &#123;</span><br><span class="line">  print: function () &#123;</span><br><span class="line">    console.log(&apos;hello&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 实例对象</span><br><span class="line">var B = Object.create(A);</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(B) === A // true</span><br><span class="line">B.print() // hello</span><br><span class="line">B.print === A.print // true</span><br></pre></td></tr></table></figure></p>
<p>下面三种方式生成的新对象是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = Object.create(&#123;&#125;);</span><br><span class="line">var obj2 = Object.create(Object.prototype);</span><br><span class="line">var obj3 = new Object();</span><br></pre></td></tr></table></figure></p>
<p><strong>使用Object.create方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。</strong><br><code>Object.create</code>方法生成的新对象，动态继承了原型。在原型上做任何修改都会立刻反映到新对象上。<br><code>Object.create</code>方法还接收第二个参数，可以添加实例对象的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.create(&#123;&#125;, &#123;</span><br><span class="line">  p1: &#123;</span><br><span class="line">    value: 123,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  p2: &#123;</span><br><span class="line">    value: &apos;abc&apos;,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var obj = Object.create(&#123;&#125;);</span><br><span class="line">obj.p1 = 123;</span><br><span class="line">obj.p2 = &apos;abc&apos;;</span><br></pre></td></tr></table></figure></p>
<p><code>Object.create</code>方法生成的对象，继承了它原型对象的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;&#125;</span><br><span class="line">var a = new A();</span><br><span class="line">var b = Object.create(a);</span><br><span class="line"></span><br><span class="line">b.constructor === A //true</span><br><span class="line">b instanceof A //true</span><br></pre></td></tr></table></figure></p>
<p>上面代码，<code>b</code>对象的原型是<code>a</code>对象，因此继承了<code>a</code>对象的构造函数<code>A</code>。</p>
<h3 id="Object-prototype-isPrototypeOf"><a href="#Object-prototype-isPrototypeOf" class="headerlink" title="Object.prototype.isPrototypeOf()"></a>Object.prototype.isPrototypeOf()</h3><p><code>isPortotypeOf</code>方法，可以用来判断该对象是否为参数对象的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = Object.create(o1);</span><br><span class="line">var o3 = Object.create(o2);</span><br><span class="line"></span><br><span class="line">o2.isPrototypeOf(o3) // true</span><br><span class="line">o1.isPrototypeOf(o3) // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>o1</code>和<code>o2</code>都是<code>o3</code>的原型。这表明只要原型对象处在参数对象的原型链上，<code>isPrototypeOf</code>方法都返回 <code>true</code>。<br><strong>由于<code>Object.prototype</code>处于原型链的最顶端，所以对于各种实例对象（{},[],/xyz/）都返回<code>true</code>，只有直接继承自<code>null</code>的对象除外。</strong></p>
<h3 id="Object-prototype-proto"><a href="#Object-prototype-proto" class="headerlink" title="Object.prototype.proto"></a>Object.prototype.<strong>proto</strong></h3><p>实例对象的<strong>proto</strong>，返回该对象的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var p = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__ = p;</span><br><span class="line">Object.getPrototypeOf(obj) === p // true</span><br></pre></td></tr></table></figure></p>
<p>可以看到上面代码，通过<code>__proto__</code>属性，将<code>p</code>对象设为<code>obj</code>的原型。<br>该属性可读写，但是根据语言标准，<code>__proto__</code>属性只有浏览器才需要部署。因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeof()</code>和<code>Object.setPrototypeOf</code>，进行原型对象的读写操作。</p>
<h3 id="获取原型对象方法的比较"><a href="#获取原型对象方法的比较" class="headerlink" title="获取原型对象方法的比较"></a>获取原型对象方法的比较</h3><p><strong><strong>proto</strong>属性指向当前对象的原型对象，即构造函数的<code>prototype</code></strong>属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line"></span><br><span class="line">obj.__proto__ === Object.prototype</span><br><span class="line">// true</span><br><span class="line">obj.__proto__ === obj.constructor.prototype</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<p>因此，获取实例对象<code>obj</code>的原型对象，有三种方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__</span><br><span class="line">obj.constructor.prototype</span><br><span class="line">Object.getPrototypeOf(obj)</span><br></pre></td></tr></table></figure></p>
<p>上面三种方法建议使用第三种。</p>
<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p>该方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyNames(Date)</span><br><span class="line">// [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;]</span><br></pre></td></tr></table></figure></p>
<p>上面代码，方法返回<code>Date</code>所有自身的属性名。<br>可以搭配<code>Object.keys</code>方法获取可以遍历的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(Date) // []</span><br></pre></td></tr></table></figure></p>
<p>上面代码表明，<code>Date</code>对象所有自身的属性，都是不可遍历的。</p>
<h3 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p>对象实例的<code>hasOwnProperty</code>方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date.hasOwnProperty(&apos;length&apos;) // true</span><br><span class="line">Date.hasOwnProperty(&apos;toString&apos;) // false</span><br></pre></td></tr></table></figure></p>
<p> 上面代码表明，<code>length</code>是<code>Date</code>自身的属性，<code>toString</code>是继承的属性。</p>
<p><strong><code>hasOwnProperty</code></strong>方法是JavaScript之中唯一一个处理对象属性时，不会遍历原型链的方法。</p>
<h3 id="in-运算符和-for…in-循环"><a href="#in-运算符和-for…in-循环" class="headerlink" title="in 运算符和 for…in 循环"></a>in 运算符和 for…in 循环</h3><p>in 运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性还是继承的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;length&apos; in Date // true</span><br><span class="line">&apos;toString&apos; in Date // true</span><br></pre></td></tr></table></figure></p>
<p>通常用<code>in</code>运算符检查一个属性是否存在。</p>
<p>获得对象的所有可便利属性（不管是自身的还是继承的），可以使用<code>for...in</code>循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123; p1: 123 &#125;;</span><br><span class="line"></span><br><span class="line">var o2 = Object.create(o1, &#123;</span><br><span class="line">  p2: &#123; value: &quot;abc&quot;, enumerable: true &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">for (p in o2) &#123;</span><br><span class="line">  console.info(p);</span><br><span class="line">&#125;</span><br><span class="line">// p2</span><br><span class="line">// p1</span><br></pre></td></tr></table></figure></p>
<p>上面对象中，对象<code>o2</code>的<code>p2</code>属性是自身的，<code>p1</code>属性是继承的。这两个属性都会被<code>for...in</code>循环遍历。<br>可以搭配<code>hasOwnProperty</code>方法获得对象自身的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for ( var name in object ) &#123;</span><br><span class="line">  if ( object.hasOwnProperty(name) ) &#123;</span><br><span class="line">    /* loop code */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h3><p>拷贝一个对象需要：</p>
<ol>
<li>确保拷贝后的对象，与原对象具有同样的原型</li>
<li>确保拷贝后的对象，与原对象具有同样的实例属性</li>
</ol>
<h2 id="面向对象编程的模式"><a href="#面向对象编程的模式" class="headerlink" title="面向对象编程的模式"></a>面向对象编程的模式</h2><h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/09/正则表达式贪婪模式与非贪婪模式/" rel="next" title="正则表达式贪婪模式与非贪婪模式">
                <i class="fa fa-chevron-left"></i> 正则表达式贪婪模式与非贪婪模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/12/浮动与定位/" rel="prev" title="浮动与定位">
                浮动与定位 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">左冬</p>
              <p class="site-description motion-element" itemprop="description">Trust the process</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#语法"><span class="nav-number">1.</span> <span class="nav-text">语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象"><span class="nav-number">1.1.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成对象"><span class="nav-number">1.1.1.</span> <span class="nav-text">生成对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#键名"><span class="nav-number">1.1.2.</span> <span class="nav-text">键名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的引用"><span class="nav-number">1.1.3.</span> <span class="nav-text">对象的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表达式还是语句"><span class="nav-number">1.1.4.</span> <span class="nav-text">表达式还是语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取属性"><span class="nav-number">1.1.5.</span> <span class="nav-text">读取属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性的赋值"><span class="nav-number">1.1.6.</span> <span class="nav-text">属性的赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看所有属性"><span class="nav-number">1.1.7.</span> <span class="nav-text">查看所有属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete-命令"><span class="nav-number">1.1.8.</span> <span class="nav-text">delete 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#in-运算"><span class="nav-number">1.1.9.</span> <span class="nav-text">in 运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for…in-循环"><span class="nav-number">1.1.10.</span> <span class="nav-text">for…in 循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">1.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">1.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的本质"><span class="nav-number">1.2.2.</span> <span class="nav-text">数组的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#length-属性"><span class="nav-number">1.2.3.</span> <span class="nav-text">length 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#in运算符"><span class="nav-number">1.2.4.</span> <span class="nav-text">in运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for…in-循环和数组的遍历"><span class="nav-number">1.2.5.</span> <span class="nav-text">for…in 循环和数组的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的空位"><span class="nav-number">1.2.6.</span> <span class="nav-text">数组的空位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类数组对象"><span class="nav-number">1.2.7.</span> <span class="nav-text">类数组对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">1.3.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.3.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数的声明"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">函数的声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数重复声明"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">函数重复声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#圆括号运算符，return-语句和递归"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">圆括号运算符，return 语句和递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数名的提升"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">函数名的提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不能在条件语句总声明函数"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">不能在条件语句总声明函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的属性和方法"><span class="nav-number">1.3.2.</span> <span class="nav-text">函数的属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#name-属性"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">name 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#length-属性-1"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">length 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toString-NaN"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">toString()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数作用域"><span class="nav-number">1.3.3.</span> <span class="nav-text">函数作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-1"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数内部的变量提升"><span class="nav-number">1.3.4.</span> <span class="nav-text">函数内部的变量提升</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数本身的作用域"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">函数本身的作用域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数"><span class="nav-number">1.3.5.</span> <span class="nav-text">参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述-1"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同名参数"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">同名参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#arguments-对象"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">arguments 对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eval命令"><span class="nav-number">1.3.6.</span> <span class="nav-text">eval命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符"><span class="nav-number">1.4.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加法运算符"><span class="nav-number">1.4.1.</span> <span class="nav-text">加法运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本规则"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">基本规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的相加"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">对象的相加</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算数运算符"><span class="nav-number">1.4.2.</span> <span class="nav-text">算数运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#余数运算符"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">余数运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自增自减运算符"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">自增自减运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数值运算符，负数值运算符"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">数值运算符，负数值运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较运算符"><span class="nav-number">1.4.3.</span> <span class="nav-text">比较运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串的比较"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">字符串的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非字符串的比较"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">非字符串的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#原始类型的值"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">原始类型的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对象-1"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#严格相等运算符"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">严格相等运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布尔运算符"><span class="nav-number">1.4.4.</span> <span class="nav-text">布尔运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#取反运算符"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">取反运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#且运算符（-amp-amp-）"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">且运算符（&amp;&amp;）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#或运算符（-）"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">或运算符（||）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三元运算符（-）"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">三元运算符（?:）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位运算"><span class="nav-number">1.4.5.</span> <span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他运算符"><span class="nav-number">1.4.6.</span> <span class="nav-text">其他运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算顺序"><span class="nav-number">1.4.7.</span> <span class="nav-text">运算顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">优先级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型转换"><span class="nav-number">1.5.</span> <span class="nav-text">数据类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#强制转换"><span class="nav-number">1.5.1.</span> <span class="nav-text">强制转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Number"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Number()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">String()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Boolean"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">Boolean()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动转换"><span class="nav-number">1.5.2.</span> <span class="nav-text">自动转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标准库"><span class="nav-number">2.</span> <span class="nav-text">标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object对象"><span class="nav-number">2.1.</span> <span class="nav-text">Object对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-2"><span class="nav-number">2.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object"><span class="nav-number">2.1.2.</span> <span class="nav-text">Object()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-构造函数"><span class="nav-number">2.1.3.</span> <span class="nav-text">Object 构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-的静态方法"><span class="nav-number">2.1.4.</span> <span class="nav-text">Object 的静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-的实例方法"><span class="nav-number">2.1.5.</span> <span class="nav-text">Object 的实例方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-对象"><span class="nav-number">2.2.</span> <span class="nav-text">Array 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">2.2.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arra-isArray"><span class="nav-number">2.2.2.</span> <span class="nav-text">Arra.isArray()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array实例的方法"><span class="nav-number">2.2.3.</span> <span class="nav-text">Array实例的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包装对象"><span class="nav-number">2.3.</span> <span class="nav-text">包装对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#包装对象的定义"><span class="nav-number">2.3.1.</span> <span class="nav-text">包装对象的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包装对象实例的方法"><span class="nav-number">2.3.2.</span> <span class="nav-text">包装对象实例的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原始类型的自动转换"><span class="nav-number">2.3.3.</span> <span class="nav-text">原始类型的自动转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义方法"><span class="nav-number">2.3.4.</span> <span class="nav-text">自定义方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Boolean-对象"><span class="nav-number">2.3.5.</span> <span class="nav-text">Boolean 对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number-对象"><span class="nav-number">2.4.</span> <span class="nav-text">Number 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-对象实例的方法"><span class="nav-number">2.4.1.</span> <span class="nav-text">Number 对象实例的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义方法-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">自定义方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-对象"><span class="nav-number">2.5.</span> <span class="nav-text">String 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Strng-fromCharCode"><span class="nav-number">2.5.1.</span> <span class="nav-text">Strng.fromCharCode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例对象的属性和方法"><span class="nav-number">2.5.2.</span> <span class="nav-text">实例对象的属性和方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math-对象"><span class="nav-number">2.6.</span> <span class="nav-text">Math 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">2.6.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三角函数方法"><span class="nav-number">2.6.2.</span> <span class="nav-text">三角函数方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Date-对象"><span class="nav-number">2.7.</span> <span class="nav-text">Date 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new-Date"><span class="nav-number">2.7.1.</span> <span class="nav-text">new Date()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期的运算"><span class="nav-number">2.7.2.</span> <span class="nav-text">日期的运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Date对象的静态方法"><span class="nav-number">2.7.3.</span> <span class="nav-text">Date对象的静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Date-实例对象的方法"><span class="nav-number">2.7.4.</span> <span class="nav-text">Date 实例对象的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RegExp对象"><span class="nav-number">2.8.</span> <span class="nav-text">RegExp对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正则对象的属性和方法"><span class="nav-number">2.8.1.</span> <span class="nav-text">正则对象的属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#test"><span class="nav-number">2.8.1.2.</span> <span class="nav-text">test()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exce"><span class="nav-number">2.8.1.3.</span> <span class="nav-text">exce()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串对象的方法"><span class="nav-number">2.8.2.</span> <span class="nav-text">字符串对象的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String-prototype-match"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">String.prototype.match()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-prototype-search"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">String.prototype.search()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-prototype-replace"><span class="nav-number">2.8.2.3.</span> <span class="nav-text">String.prototype.replace()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-prototype-split"><span class="nav-number">2.8.2.4.</span> <span class="nav-text">String.prototype.split()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匹配规则"><span class="nav-number">2.8.3.</span> <span class="nav-text">匹配规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#修饰符"><span class="nav-number">2.8.3.1.</span> <span class="nav-text">修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组匹配"><span class="nav-number">2.8.3.2.</span> <span class="nav-text">组匹配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON-对象"><span class="nav-number">2.9.</span> <span class="nav-text">JSON 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON-stringify"><span class="nav-number">2.9.1.</span> <span class="nav-text">JSON.stringify()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON-stringify-的第二个参数"><span class="nav-number">2.9.1.1.</span> <span class="nav-text">JSON.stringify() 的第二个参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toJSON-方法"><span class="nav-number">2.9.2.</span> <span class="nav-text">toJSON 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON-parse"><span class="nav-number">2.9.3.</span> <span class="nav-text">JSON.parse()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#console-对象"><span class="nav-number">2.10.</span> <span class="nav-text">console 对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象编程"><span class="nav-number">3.</span> <span class="nav-text">面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数与-new-命令"><span class="nav-number">3.1.</span> <span class="nav-text">构造函数与 new 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象是什么"><span class="nav-number">3.1.1.</span> <span class="nav-text">对象是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数-1"><span class="nav-number">3.1.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-命令"><span class="nav-number">3.1.3.</span> <span class="nav-text">new 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#new-命令的原理"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">new 命令的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-Object-create-创建实例对象"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">使用 Object.create() 创建实例对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-关键字"><span class="nav-number">3.2.</span> <span class="nav-text">this 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场合"><span class="nav-number">3.2.1.</span> <span class="nav-text">使用场合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局环境"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">全局环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数-2"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的方法"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">对象的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用注意点"><span class="nav-number">3.2.2.</span> <span class="nav-text">使用注意点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#避免多层this"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">避免多层this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免数组处理方法中的this"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">避免数组处理方法中的this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免回调函数中的this"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">避免回调函数中的this</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定-this-的方法"><span class="nav-number">3.2.3.</span> <span class="nav-text">绑定 this 的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#function-prototype-call"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">function.prototype.call()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#function-prototype-apply"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">function.prototype.apply()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#function-prototype-bind"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">function.prototype.bind()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#prototype对象"><span class="nav-number">3.3.</span> <span class="nav-text">prototype对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原型对象"><span class="nav-number">3.3.1.</span> <span class="nav-text">原型对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数-3"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prototype-属性的作用"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">prototype 属性的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型链"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constructor-属性"><span class="nav-number">3.3.1.4.</span> <span class="nav-text">constructor 属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof-运算符"><span class="nav-number">3.3.2.</span> <span class="nav-text">instanceof 运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-对象的相关方法"><span class="nav-number">3.4.</span> <span class="nav-text">Object 对象的相关方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-getPrototypeOf"><span class="nav-number">3.4.1.</span> <span class="nav-text">Object.getPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-setPrototypeOf"><span class="nav-number">3.4.2.</span> <span class="nav-text">Object.setPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-create"><span class="nav-number">3.4.3.</span> <span class="nav-text">Object.create()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-prototype-isPrototypeOf"><span class="nav-number">3.4.4.</span> <span class="nav-text">Object.prototype.isPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-prototype-proto"><span class="nav-number">3.4.5.</span> <span class="nav-text">Object.prototype.proto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取原型对象方法的比较"><span class="nav-number">3.4.6.</span> <span class="nav-text">获取原型对象方法的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-getOwnPropertyNames"><span class="nav-number">3.4.7.</span> <span class="nav-text">Object.getOwnPropertyNames()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-prototype-hasOwnProperty"><span class="nav-number">3.4.8.</span> <span class="nav-text">Object.prototype.hasOwnProperty()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#in-运算符和-for…in-循环"><span class="nav-number">3.4.9.</span> <span class="nav-text">in 运算符和 for…in 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的拷贝"><span class="nav-number">3.4.10.</span> <span class="nav-text">对象的拷贝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象编程的模式"><span class="nav-number">3.5.</span> <span class="nav-text">面向对象编程的模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数的继承"><span class="nav-number">3.5.1.</span> <span class="nav-text">构造函数的继承</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">左冬</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
